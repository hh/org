#+TITLE: registry.k8.io Envoy In K8s

Set up Envoy to rewrite the requests, 302'ing the hostname and path to a registry that's chosen by an external service.

* Deploying Envoy
** Envoy configuration
*** envoy-config.yaml
#+BEGIN_SRC yaml :tangle ./envoy-config.yaml
node:
  id: web_service
  cluster: web_service

dynamic_resources:
  lds_config:
    path: /var/lib/envoy/lds.yaml

static_resources:
  clusters:
  - name: web_service
    connect_timeout: 0.25s
    type: LOGICAL_DNS
    lb_policy: round_robin
    load_assignment:
      cluster_name: web_service
      endpoints:
      - lb_endpoints:
        - endpoint:
            address:
              socket_address:
                address: k8s.io
                port_value: 443
#+END_SRC

*** envoy-lds.yaml
#+BEGIN_SRC yaml :tangle ./envoy-lds.yaml
resources:
- "@type": type.googleapis.com/envoy.config.listener.v3.Listener
  name: listener_0
  address:
    socket_address:
      address: 0.0.0.0
      port_value: 10000
  filter_chains:
  - filters:
      name: envoy.http_connection_manager
      typed_config:
        "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
        stat_prefix: ingress_http
        route_config:
          name: local_route
          virtual_hosts:
          - name: local_service
            domains:
            - "*"
            routes:
            - match:
                prefix: "/"
              route:
                cluster: web_service
        http_filters:
          - name: envoy.filters.http.lua
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua
              inline_code: |
                local reg1 = "k8s.gcr.io"
                local reg2 = "registry-1.docker.io"
                local reg2WithIP = "192.168.0.1"
                function envoy_on_request(request_handle)
                  local reg = reg1
                  remoteAddr = request_handle:headers():get("x-real-ip")
                  if remoteAddr == reg2WithIP then
                    request_handle:logInfo("remoteAddr: "..reg2WithIP)
                    reg = reg2
                  end
                  request_handle:logInfo("REG: "..reg)
                  request_handle:logInfo("REMOTEADDR: "..remoteAddr)
                  -- request_handle:logInfo("Hello")
                  if request_handle:headers():get(":method") == "GET" then
                    request_handle:respond(
                      {
                        [":status"] = "302",
                        ["location"] = "https://"..reg..request_handle:headers():get(":path"),
                        ["Content-Type"] = "text/html; charset=utf-8",
                        [":authority"] = "web_service"
                      },
                      '<a href="'.."https://"..reg..request_handle:headers():get(":path")..'">'.."302".."</a>.\n")
                  end
                end
          - name: envoy.filters.http.router
            typed_config: {}
#+END_SRC

** Apply configuration
#+BEGIN_SRC shell :results silent
kubectl create configmap envoy-config --from-file=envoy\.yaml=envoy-config.yaml --dry-run=client -o yaml | kubectl apply -f -
kubectl create configmap envoy-config-lds --from-file=lds\.yaml=envoy-lds.yaml --dry-run=client -o yaml | kubectl apply -f -
#+END_SRC

** Deploying Envoy
#+BEGIN_SRC yaml :tangle ./envoy.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  # annotations:
  #   lastcfg: |
  #     ${ENVOY_LAST_CFG}
  labels:
    app: registry-k8s-io-envoy
  name: registry-k8s-io-envoy
spec:
  replicas: 1
  selector:
    matchLabels:
      app: registry-k8s-io-envoy
  template:
    metadata:
      # annotations:
      #   lastcfg: |
      #     ${ENVOY_LAST_CFG}
      labels:
        app: registry-k8s-io-envoy
    spec:
      containers:
      - name: envoy
        command:
        - /usr/local/bin/envoy
        - -c
        - /etc/envoy/envoy.yaml
        - -l
        - debug
        image: envoyproxy/envoy-dev:latest
        volumeMounts:
          - name: envoy-config
            mountPath: /etc/envoy/
          - name: envoy-config-lds
            mountPath: /var/lib/envoy/
        ports:
          - name: http
            containerPort: 10000
      volumes:
      - name: envoy-config
        configMap:
          name: envoy-config
      - name: envoy-config-lds
        configMap:
          name: envoy-config-lds
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app: registry-k8s-io-envoy
  name: registry-k8s-io-envoy
spec:
  ports:
  - name: registry-k8s-io
    port: 10000
    protocol: TCP
    targetPort: 10000
  selector:
    app: registry-k8s-io-envoy
  type: ClusterIP
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: registry-k8s-io-envoy
spec:
  rules:
  - host: registry-k8s-io.${SHARINGIO_PAIR_BASE_DNS_NAME}
    http:
      paths:
      - backend:
          service:
            name: registry-k8s-io-envoy
            port:
              number: 10000
        path: /
        pathType: ImplementationSpecific
  tls:
  - hosts:
    - registry-k8s-io.${SHARINGIO_PAIR_BASE_DNS_NAME}
    secretName: letsencrypt-prod
#+END_SRC

#+BEGIN_SRC shell :results silent
export ENVOY_LAST_CFG=$(cat envoy-config.yaml | sha256sum)
envsubst < envoy.yaml | kubectl apply -f -
#+END_SRC

#+BEGIN_SRC shell :results silent
kubectl delete -f envoy.yaml
#+END_SRC
