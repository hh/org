#+TITLE: ii cluster

#+begin_quote
A cluster for things that ii uses both internally and externally
#+end_quote

* Initialize the packet plugin for Cluster-API
Export credentials for Cluster-API + Packet running in kind to use
#+begin_src tmate :window cluster :session packet-cluster-api :noweb yes
read -p 'PACKET_PROJECT_ID: ' PACKET_PROJECT_ID && \
export PACKET_PROJECT_ID && \
read -p 'PACKET_API_KEY: ' PACKET_API_KEY && \
export PACKET_API_KEY && \
clusterctl init --infrastructure=packet
#+end_src

* Set up cluster
#+NAME: Cluster-API manifests
#+begin_src yaml :tangle ./gitlab-cluster-capi-template.yaml
kind: KubeadmControlPlane
apiVersion: controlplane.cluster.x-k8s.io/v1alpha3
metadata:
  name: "${CLUSTER_NAME}-control-plane"
spec:
  version: ${KUBERNETES_VERSION}
  replicas: ${CONTROL_PLANE_MACHINE_COUNT}
  infrastructureTemplate:
    apiVersion: infrastructure.cluster.x-k8s.io/v1alpha3
    kind: PacketMachineTemplate
    name: "${CLUSTER_NAME}-control-plane"
  kubeadmConfigSpec:
    initConfiguration:
      nodeRegistration:
        kubeletExtraArgs:
          cloud-provider: external
    clusterConfiguration:
      apiServer:
        extraArgs:
          cloud-provider: external
      controllerManager:
        extraArgs:
          cloud-provider: external
    joinConfiguration:
      nodeRegistration:
        kubeletExtraArgs:
          cloud-provider: external
    postKubeadmCommands:
      - |
        cat <<EOF >> /etc/network/interfaces
        auto lo:0
        iface lo:0 inet static
          address {{ .controlPlaneEndpoint }}
          netmask 255.255.255.255
        EOF
      - systemctl restart networking
      - mkdir -p ~/.kube/
      - cp /etc/kubernetes/admin.conf ~/.kube/config
      - 'kubectl create secret generic -n kube-system metal-cloud-config --from-literal=cloud-sa.json=''{"apiKey": "{{ .apiKey }}","projectID": "${PROJECT_ID}","loadbalancer":"metallb:///"}'''
      - kubectl apply -f https://github.com/equinix/cloud-provider-equinix-metal/releases/download/v3.2.2/deployment.yaml
      - kubectl taint node --all node-role.kubernetes.io/master-
    preKubeadmCommands:
      - sed -ri '/\sswap\s/s/^#?/#/' /etc/fstab
      - swapoff -a
      - mount -a
      - |
        cat <<EOF > /etc/modules-load.d/containerd.conf
        overlay
        br_netfilter
        EOF
      - modprobe overlay
      - modprobe br_netfilter
      - |
        cat <<EOF > /etc/sysctl.d/99-kubernetes-cri.conf
        net.bridge.bridge-nf-call-iptables  = 1
        net.ipv4.ip_forward                 = 1
        net.bridge.bridge-nf-call-ip6tables = 1
        EOF
      - sysctl --system
      - apt-get -y update
      - DEBIAN_FRONTEND=noninteractive apt-get install -y apt-transport-https curl
      - curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -
      - echo "deb https://apt.kubernetes.io/ kubernetes-xenial main" > /etc/apt/sources.list.d/kubernetes.list
      - apt-get update -y
      - TRIMMED_KUBERNETES_VERSION=$(echo {{ .kubernetesVersion }} | sed 's/\./\\./g' | sed 's/^v//')
      - RESOLVED_KUBERNETES_VERSION=$(apt-cache policy kubelet | awk -v VERSION=$${TRIMMED_KUBERNETES_VERSION} '$1~ VERSION { print $1 }' | head -n1)
      - apt-get install -y ca-certificates socat jq ebtables apt-transport-https cloud-utils prips containerd kubelet=$${RESOLVED_KUBERNETES_VERSION} kubeadm=$${RESOLVED_KUBERNETES_VERSION} kubectl=$${RESOLVED_KUBERNETES_VERSION}
      - systemctl daemon-reload
      - systemctl enable containerd
      - systemctl start containerd
      - ping -c 3 -q {{ .controlPlaneEndpoint }} && echo OK || ip addr add {{ .controlPlaneEndpoint }} dev lo
---
apiVersion: infrastructure.cluster.x-k8s.io/v1alpha3
kind: PacketMachineTemplate
metadata:
  name: "${CLUSTER_NAME}-control-plane"
spec:
  template:
    spec:
      OS: "${NODE_OS:=ubuntu_18_04}"
      billingCycle: hourly
      machineType: "${CONTROLPLANE_NODE_TYPE}"
      sshKeys:
        - "${SSH_KEY}"
      tags: []
---
apiVersion: cluster.x-k8s.io/v1alpha3
kind: Cluster
metadata:
  name: "${CLUSTER_NAME}"
spec:
  clusterNetwork:
    pods:
      cidrBlocks:
        - ${POD_CIDR:=192.168.0.0/16}
    services:
      cidrBlocks:
        - ${SERVICE_CIDR:=172.26.0.0/16}
  infrastructureRef:
    apiVersion: infrastructure.cluster.x-k8s.io/v1alpha3
    kind: PacketCluster
    name: "${CLUSTER_NAME}"
  controlPlaneRef:
    apiVersion: controlplane.cluster.x-k8s.io/v1alpha3
    kind: KubeadmControlPlane
    name: "${CLUSTER_NAME}-control-plane"
---
apiVersion: infrastructure.cluster.x-k8s.io/v1alpha3
kind: PacketCluster
metadata:
  name: "${CLUSTER_NAME}"
spec:
  projectID: "${PROJECT_ID}"
  facility: "${FACILITY}"
---
apiVersion: cluster.x-k8s.io/v1alpha3
kind: MachineDeployment
metadata:
  name: ${CLUSTER_NAME}-worker-a
  labels:
    cluster.x-k8s.io/cluster-name: ${CLUSTER_NAME}
    pool: worker-a
spec:
  replicas: ${WORKER_MACHINE_COUNT}
  clusterName: ${CLUSTER_NAME}
  selector:
    matchLabels:
      cluster.x-k8s.io/cluster-name: ${CLUSTER_NAME}
      pool: worker-a
  template:
    metadata:
      labels:
        cluster.x-k8s.io/cluster-name: ${CLUSTER_NAME}
        pool: worker-a
    spec:
      version: ${KUBERNETES_VERSION}
      clusterName: ${CLUSTER_NAME}
      bootstrap:
        configRef:
          name: ${CLUSTER_NAME}-worker-a
          apiVersion: bootstrap.cluster.x-k8s.io/v1alpha3
          kind: KubeadmConfigTemplate
      infrastructureRef:
        name: ${CLUSTER_NAME}-worker-a
        apiVersion: infrastructure.cluster.x-k8s.io/v1alpha3
        kind: PacketMachineTemplate
---
apiVersion: infrastructure.cluster.x-k8s.io/v1alpha3
kind: PacketMachineTemplate
metadata:
  name: ${CLUSTER_NAME}-worker-a
spec:
  template:
    spec:
      OS: "${NODE_OS:=ubuntu_18_04}"
      billingCycle: hourly
      machineType: "${WORKER_NODE_TYPE}"
      sshKeys:
        - "${SSH_KEY}"
      tags: []
---
kind: KubeadmConfigTemplate
apiVersion: bootstrap.cluster.x-k8s.io/v1alpha3
metadata:
  name: "${CLUSTER_NAME}-worker-a"
spec:
  template:
    spec:
      preKubeadmCommands:
        - sed -ri '/\sswap\s/s/^#?/#/' /etc/fstab
        - swapoff -a
        - mount -a
        - |
          cat <<EOF > /etc/modules-load.d/containerd.conf
          overlay
          br_netfilter
          EOF
        - modprobe overlay
        - modprobe br_netfilter
        - |
          cat <<EOF > /etc/sysctl.d/99-kubernetes-cri.conf
          net.bridge.bridge-nf-call-iptables  = 1
          net.ipv4.ip_forward                 = 1
          net.bridge.bridge-nf-call-ip6tables = 1
          EOF
        - sysctl --system
        - apt-get -y update
        - DEBIAN_FRONTEND=noninteractive apt-get install -y apt-transport-https curl
        - curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -
        - echo "deb https://apt.kubernetes.io/ kubernetes-xenial main" > /etc/apt/sources.list.d/kubernetes.list
        - apt-get update -y
        - TRIMMED_KUBERNETES_VERSION=$(echo {{ .kubernetesVersion }} | sed 's/\./\\./g' | sed 's/^v//')
        - RESOLVED_KUBERNETES_VERSION=$(apt-cache policy kubelet | awk -v VERSION=$${TRIMMED_KUBERNETES_VERSION} '$1~ VERSION { print $1 }' | head -n1)
        - apt-get install -y ca-certificates socat jq ebtables apt-transport-https cloud-utils prips containerd kubelet=$${RESOLVED_KUBERNETES_VERSION} kubeadm=$${RESOLVED_KUBERNETES_VERSION} kubectl=$${RESOLVED_KUBERNETES_VERSION}
        - systemctl daemon-reload
        - systemctl enable containerd
        - systemctl start containerd
      joinConfiguration:
        nodeRegistration:
          kubeletExtraArgs:
            cloud-provider: external
#+end_src

#+NAME: Start a window
#+begin_src tmate :dir . :window cluster
#+end_src

#+NAME: Generate cluster-api manifests
#+begin_src tmate :dir . :window cluster :noweb yes
export CLUSTER_NAME="ii-coop"
export FACILITY=sjc1
export KUBERNETES_VERSION=v1.21.1
export POD_CIDR=10.244.0.0/16
export SERVICE_CIDR=10.96.0.0/12
export NODE_OS=ubuntu_20_04
export CONTROLPLANE_NODE_TYPE=m1.xlarge.x86
export CONTROL_PLANE_MACHINE_COUNT=3
export WORKER_NODE_TYPE=$CONTROLPLANE_NODE_TYPE
export WORKER_MACHINE_COUNT=0
export SSH_KEY=""
export PROJECT_ID=$PACKET_PROJECT_ID
clusterctl config cluster "$CLUSTER_NAME" --from ./gitlab-cluster-capi-template.yaml -n "$CLUSTER_NAME" > "$CLUSTER_NAME"-cluster-capi.yaml
#+end_src

#+NAME: Create box
#+begin_src tmate :dir . :window cluster
kubectl create ns ii-coop 2> /dev/null
kubectl -n ii-coop apply -f ./ii-coop-cluster-capi.yaml
#+end_src

The cluster will now be brought up, we can see the progress by taking a look at the resources:
#+begin_src tmate
kubectl -n ii-coop get machines,clusters,packetmachines,packetclusters
#+end_src

Note that the nodes in the cluster will remain not ready until the CNI is applied.

#+NAME: Get Kubeconfig
#+begin_src tmate :dir . :window cluster
kubectl -n ii-coop get secret ii-coop-kubeconfig -o=jsonpath='{.data.value}' | base64 -d > ~/.kube/config-ii-coop
export KUBECONFIG=~/.kube/config-ii-coop
#+end_src

#+NAME: Ensure all nodes are scheduable
#+begin_src tmate :dir . :window cluster
kubectl taint node --all node-role.kubernetes.io/master-
#+end_src

* Export KUBECONFIG to ii-coop
#+begin_src tmate :window cluster
export KUBECONFIG=~/.kube/config-ii-coop
#+end_src

* CNI

#+NAME: Weave CNI
#+begin_src tmate :dir . :window cluster
curl -o weave-net.yaml -L "https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\n')&env.IPALLOC_RANGE=192.168.0.0/16"
kubectl apply -f ./weave-net.yaml
#+end_src

* Helm-Operator
#+NAME: Helm-Operator
#+begin_src tmate :dir . :window cluster
curl -o ./helm-operator-crds.yaml -L https://raw.githubusercontent.com/fluxcd/helm-operator/1.4.0/deploy/crds.yaml

helm repo add fluxcd https://charts.fluxcd.io
helm template helm-operator --create-namespace fluxcd/helm-operator \
    --version 1.4.0 \
    --namespace helm-operator \
    --set helm.versions=v3 > ./helm-operator.yaml
#+end_src

#+begin_src tmate :dir . :window cluster
kubectl create namespace helm-operator
kubectl apply -f ./helm-operator-crds.yaml -f ./helm-operator.yaml
#+end_src

* Rook + Ceph
#+begin_src tmate :dir . :window cluster
kubectl create ns rook-ceph
#+end_src

#+begin_src shell :results silent
curl -s -L -o ./rook-ceph-common.yaml https://github.com/rook/rook/raw/v1.7.2/cluster/examples/kubernetes/ceph/common.yaml
curl -s -L -o ./rook-ceph-crds.yaml https://github.com/rook/rook/raw/v1.7.2/cluster/examples/kubernetes/ceph/crds.yaml
curl -s -L -o ./rook-ceph-operator.yaml https://github.com/rook/rook/raw/v1.7.2/cluster/examples/kubernetes/ceph/operator.yaml
#+end_src

#+begin_src tmate :dir . :window cluster
kubectl apply -f ./rook-ceph-crds.yaml -f ./rook-ceph-common.yaml -f ./rook-ceph-operator.yaml
#+end_src

#+begin_src yaml :tangle ./rook-ceph-cluster.yaml
#################################################################################################################
# Define the settings for the rook-ceph cluster with common settings for a production cluster.
# All nodes with available raw devices will be used for the Ceph cluster. At least three nodes are required
# in this example. See the documentation for more details on storage settings available.

# For example, to create the cluster:
#   kubectl create -f crds.yaml -f common.yaml -f operator.yaml
#   kubectl create -f cluster.yaml
#################################################################################################################

apiVersion: ceph.rook.io/v1
kind: CephCluster
metadata:
  name: rook-ceph
  namespace: rook-ceph # namespace:cluster
spec:
  cephVersion:
    # The container image used to launch the Ceph daemon pods (mon, mgr, osd, mds, rgw).
    # v13 is mimic, v14 is nautilus, and v15 is octopus.
    # RECOMMENDATION: In production, use a specific version tag instead of the general v14 flag, which pulls the latest release and could result in different
    # versions running within the cluster. See tags available at https://hub.docker.com/r/ceph/ceph/tags/.
    # If you want to be more precise, you can always use a timestamp tag such ceph/ceph:v15.2.8-20201217
    # This tag might not contain a new Ceph version, just security fixes from the underlying operating system, which will reduce vulnerabilities
    image: ceph/ceph:v16.2.5
    # Whether to allow unsupported versions of Ceph. Currently `nautilus` and `octopus` are supported.
    # Future versions such as `pacific` would require this to be set to `true`.
    # Do not set to true in production.
    allowUnsupported: false
  # The path on the host where configuration files will be persisted. Must be specified.
  # Important: if you reinstall the cluster, make sure you delete this directory from each host or else the mons will fail to start on the new cluster.
  # In Minikube, the '/data' directory is configured to persist across reboots. Use "/data/rook" in Minikube environment.
  dataDirHostPath: /var/lib/rook
  # Whether or not upgrade should continue even if a check fails
  # This means Ceph's status could be degraded and we don't recommend upgrading but you might decide otherwise
  # Use at your OWN risk
  # To understand Rook's upgrade process of Ceph, read https://rook.io/docs/rook/master/ceph-upgrade.html#ceph-version-upgrades
  skipUpgradeChecks: false
  # Whether or not continue if PGs are not clean during an upgrade
  continueUpgradeAfterChecksEvenIfNotHealthy: false
  mon:
    # Set the number of mons to be started. Must be an odd number, and is generally recommended to be 3.
    count: 3
    # The mons should be on unique nodes. For production, at least 3 nodes are recommended for this reason.
    # Mons should only be allowed on the same node for test environments where data loss is acceptable.
    allowMultiplePerNode: false
  mgr:
    modules:
    # Several modules should not need to be included in this list. The "dashboard" and "monitoring" modules
    # are already enabled by other settings in the cluster CR.
    - name: pg_autoscaler
      enabled: true
  # enable the ceph dashboard for viewing cluster status
  dashboard:
    enabled: true
    # serve the dashboard under a subpath (useful when you are accessing the dashboard via a reverse proxy)
    # urlPrefix: /ceph-dashboard
    # serve the dashboard at the given port.
    # port: 8443
    # serve the dashboard using SSL
    ssl: true
  # enable prometheus alerting for cluster
  monitoring:
    # requires Prometheus to be pre-installed
    enabled: false
    # namespace to deploy prometheusRule in. If empty, namespace of the cluster will be used.
    # Recommended:
    # If you have a single rook-ceph cluster, set the rulesNamespace to the same namespace as the cluster or keep it empty.
    # If you have multiple rook-ceph clusters in the same k8s cluster, choose the same namespace (ideally, namespace with prometheus
    # deployed) to set rulesNamespace for all the clusters. Otherwise, you will get duplicate alerts with multiple alert definitions.
    rulesNamespace: rook-ceph
  network:
    # enable host networking
    #provider: host
    # EXPERIMENTAL: enable the Multus network provider
    #provider: multus
    #selectors:
      # The selector keys are required to be `public` and `cluster`.
      # Based on the configuration, the operator will do the following:
      #   1. if only the `public` selector key is specified both public_network and cluster_network Ceph settings will listen on that interface
      #   2. if both `public` and `cluster` selector keys are specified the first one will point to 'public_network' flag and the second one to 'cluster_network'
      #
      # In order to work, each selector value must match a NetworkAttachmentDefinition object in Multus
      #
      #public: public-conf --> NetworkAttachmentDefinition object name in Multus
      #cluster: cluster-conf --> NetworkAttachmentDefinition object name in Multus
    # Provide internet protocol version. IPv6, IPv4 or empty string are valid options. Empty string would mean IPv4
    #ipFamily: "IPv6"
  # enable the crash collector for ceph daemon crash collection
  crashCollector:
    disable: false
  # enable log collector, daemons will log on files and rotate
  # logCollector:
  #   enabled: true
  #   periodicity: 24h # SUFFIX may be 'h' for hours or 'd' for days.
  # automate [data cleanup process](https://github.com/rook/rook/blob/master/Documentation/ceph-teardown.md#delete-the-data-on-hosts) in cluster destruction.
  cleanupPolicy:
    # Since cluster cleanup is destructive to data, confirmation is required.
    # To destroy all Rook data on hosts during uninstall, confirmation must be set to "yes-really-destroy-data".
    # This value should only be set when the cluster is about to be deleted. After the confirmation is set,
    # Rook will immediately stop configuring the cluster and only wait for the delete command.
    # If the empty string is set, Rook will not destroy any data on hosts during uninstall.
    confirmation: ""
    # sanitizeDisks represents settings for sanitizing OSD disks on cluster deletion
    sanitizeDisks:
      # method indicates if the entire disk should be sanitized or simply ceph's metadata
      # in both case, re-install is possible
      # possible choices are 'complete' or 'quick' (default)
      method: quick
      # dataSource indicate where to get random bytes from to write on the disk
      # possible choices are 'zero' (default) or 'random'
      # using random sources will consume entropy from the system and will take much more time then the zero source
      dataSource: zero
      # iteration overwrite N times instead of the default (1)
      # takes an integer value
      iteration: 1
    # allowUninstallWithVolumes defines how the uninstall should be performed
    # If set to true, cephCluster deletion does not wait for the PVs to be deleted.
    allowUninstallWithVolumes: false
  # To control where various services will be scheduled by kubernetes, use the placement configuration sections below.
  # The example under 'all' would have all services scheduled on kubernetes nodes labeled with 'role=storage-node' and
  # tolerate taints with a key of 'storage-node'.
#  placement:
#    all:
#      nodeAffinity:
#        requiredDuringSchedulingIgnoredDuringExecution:
#          nodeSelectorTerms:
#          - matchExpressions:
#            - key: role
#              operator: In
#              values:
#              - storage-node
#      podAffinity:
#      podAntiAffinity:
#      topologySpreadConstraints:
#      tolerations:
#      - key: storage-node
#        operator: Exists
# The above placement information can also be specified for mon, osd, and mgr components
#    mon:
# Monitor deployments may contain an anti-affinity rule for avoiding monitor
# collocation on the same node. This is a required rule when host network is used
# or when AllowMultiplePerNode is false. Otherwise this anti-affinity rule is a
# preferred rule with weight: 50.
#    osd:
#    mgr:
#    cleanup:
  annotations:
#    all:
#    mon:
#    osd:
#    cleanup:
#    prepareosd:
# If no mgr annotations are set, prometheus scrape annotations will be set by default.
#    mgr:
  labels:
#    all:
#    mon:
#    osd:
#    cleanup:
#    mgr:
#    prepareosd:
  resources:
# The requests and limits set here, allow the mgr pod to use half of one CPU core and 1 gigabyte of memory
#    mgr:
#      limits:
#        cpu: "500m"
#        memory: "1024Mi"
#      requests:
#        cpu: "500m"
#        memory: "1024Mi"
# The above example requests/limits can also be added to the mon and osd components
#    mon:
#    osd:
#    prepareosd:
#    crashcollector:
#    logcollector:
#    cleanup:
  # The option to automatically remove OSDs that are out and are safe to destroy.
  removeOSDsIfOutAndSafeToRemove: false
#  priorityClassNames:
#    all: rook-ceph-default-priority-class
#    mon: rook-ceph-mon-priority-class
#    osd: rook-ceph-osd-priority-class
#    mgr: rook-ceph-mgr-priority-class
  storage: # cluster level storage configuration and selection
    useAllNodes: true
    useAllDevices: false
    deviceFilter: "^sd[c-f]"
    # config:
      # crushRoot: "custom-root" # specify a non-default root label for the CRUSH map
      # metadataDevice: "md0" # specify a non-rotational storage so ceph-volume will use it as block db device of bluestore.
      # databaseSizeMB: "1024" # uncomment if the disks are smaller than 100 GB
      # journalSizeMB: "1024"  # uncomment if the disks are 20 GB or smaller
      # osdsPerDevice: "1" # this value can be overridden at the node or device level
      # encryptedDevice: "true" # the default value for this option is "false"
# Individual nodes and their config can be specified as well, but 'useAllNodes' above must be set to false. Then, only the named
# nodes below will be used as storage resources.  Each node's 'name' field should match their 'kubernetes.io/hostname' label.
#    nodes:
#    - name: "172.17.4.201"
#      devices: # specific devices to use for storage can be specified for each node
#      - name: "sdb"
#      - name: "nvme01" # multiple osds can be created on high performance devices
#        config:
#          osdsPerDevice: "5"
#      - name: "/dev/disk/by-id/ata-ST4000DM004-XXXX" # devices can be specified using full udev paths
#      config: # configuration can be specified at the node level which overrides the cluster level config
#        storeType: filestore
#    - name: "172.17.4.301"
#      deviceFilter: "^sd."
  # The section for configuring management of daemon disruptions during upgrade or fencing.
  disruptionManagement:
    # If true, the operator will create and manage PodDisruptionBudgets for OSD, Mon, RGW, and MDS daemons. OSD PDBs are managed dynamically
    # via the strategy outlined in the [design](https://github.com/rook/rook/blob/master/design/ceph/ceph-managed-disruptionbudgets.md). The operator will
    # block eviction of OSDs by default and unblock them safely when drains are detected.
    managePodBudgets: false
    # A duration in minutes that determines how long an entire failureDomain like `region/zone/host` will be held in `noout` (in addition to the
    # default DOWN/OUT interval) when it is draining. This is only relevant when  `managePodBudgets` is `true`. The default value is `30` minutes.
    osdMaintenanceTimeout: 30
    # A duration in minutes that the operator will wait for the placement groups to become healthy (active+clean) after a drain was completed and OSDs came back up.
    # Operator will continue with the next drain if the timeout exceeds. It only works if `managePodBudgets` is `true`.
    # No values or 0 means that the operator will wait until the placement groups are healthy before unblocking the next drain.
    pgHealthCheckTimeout: 0
    # If true, the operator will create and manage MachineDisruptionBudgets to ensure OSDs are only fenced when the cluster is healthy.
    # Only available on OpenShift.
    manageMachineDisruptionBudgets: false
    # Namespace in which to watch for the MachineDisruptionBudgets.
    machineDisruptionBudgetNamespace: openshift-machine-api

  # healthChecks
  # Valid values for daemons are 'mon', 'osd', 'status'
  healthCheck:
    daemonHealth:
      mon:
        disabled: false
        interval: 45s
      osd:
        disabled: false
        interval: 60s
      status:
        disabled: false
        interval: 60s
    # Change pod liveness probe, it works for all mon,mgr,osd daemons
    livenessProbe:
      mon:
        disabled: false
      mgr:
        disabled: false
      osd:
        disabled: false
#+end_src

#+begin_src tmate :dir . :window cluster
kubectl apply -f ./rook-ceph-cluster.yaml
#+end_src

#+begin_src yaml :tangle ./rook-ceph-pool-storageclass.yaml
apiVersion: ceph.rook.io/v1
kind: CephBlockPool
metadata:
  name: replicapool
  namespace: rook-ceph
spec:
  failureDomain: host
  replicated:
    size: 3
---
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
   name: rook-ceph-block
   annotations:
     storageclass.kubernetes.io/is-default-class: "true"
# Change "rook-ceph" provisioner prefix to match the operator namespace if needed
provisioner: rook-ceph.rbd.csi.ceph.com
parameters:
    # clusterID is the namespace where the rook cluster is running
    clusterID: rook-ceph
    # Ceph pool into which the RBD image shall be created
    pool: replicapool

    # (optional) mapOptions is a comma-separated list of map options.
    # For krbd options refer
    # https://docs.ceph.com/docs/master/man/8/rbd/#kernel-rbd-krbd-options
    # For nbd options refer
    # https://docs.ceph.com/docs/master/man/8/rbd-nbd/#options
    # mapOptions: lock_on_read,queue_depth=1024

    # (optional) unmapOptions is a comma-separated list of unmap options.
    # For krbd options refer
    # https://docs.ceph.com/docs/master/man/8/rbd/#kernel-rbd-krbd-options
    # For nbd options refer
    # https://docs.ceph.com/docs/master/man/8/rbd-nbd/#options
    # unmapOptions: force

    # RBD image format. Defaults to "2".
    imageFormat: "2"

    # RBD image features. Available for imageFormat: "2". CSI RBD currently supports only `layering` feature.
    imageFeatures: layering

    # The secrets contain Ceph admin credentials.
    csi.storage.k8s.io/provisioner-secret-name: rook-csi-rbd-provisioner
    csi.storage.k8s.io/provisioner-secret-namespace: rook-ceph
    csi.storage.k8s.io/controller-expand-secret-name: rook-csi-rbd-provisioner
    csi.storage.k8s.io/controller-expand-secret-namespace: rook-ceph
    csi.storage.k8s.io/node-stage-secret-name: rook-csi-rbd-node
    csi.storage.k8s.io/node-stage-secret-namespace: rook-ceph

    # Specify the filesystem type of the volume. If not specified, csi-provisioner
    # will set default as `ext4`. Note that `xfs` is not recommended due to potential deadlock
    # in hyperconverged settings where the volume is mounted on the same node as the osds.
    csi.storage.k8s.io/fstype: ext4

# Delete the rbd volume when a PVC is deleted
reclaimPolicy: Delete
#+end_src

#+begin_src tmate :dir . :window cluster
kubectl apply -f ./rook-ceph-pool-storageclass.yaml
#+end_src

#+begin_src yaml :tangle ./rook-ceph-pvc-test.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: rook-ceph-pvc-test
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 500Gi
  storageClassName: rook-ceph-block
---
apiVersion: v1
kind: Pod
metadata:
  name: rook-ceph-pvc-test
spec:
  nodeName: ii-coop-control-plane-nbvt9
  containers:
    - name: rook-ceph-pvc-test
      image: alpine:3.12
      command:
        - sleep
        - infinity
      volumeMounts:
        - name: rook-ceph-pvc-test
          mountPath: /mnt
  volumes:
    - name: rook-ceph-pvc-test
      persistentVolumeClaim:
        claimName: rook-ceph-pvc-test
#+end_src

#+begin_src tmate :dir . :window cluster
kubectl -n default apply -f ./rook-ceph-pvc-test.yaml
#+end_src

#+begin_src tmate :dir . :window cluster
kubectl -n default exec -it rook-ceph-pvc-test -- sh
#+end_src

#+NAME: RWM storageClass
#+begin_src yaml :tangle ./rook-ceph-shared-pool-storageclass.yaml
apiVersion: ceph.rook.io/v1
kind: CephFilesystem
metadata:
  name: rook-ceph-shared
  namespace: rook-ceph
spec:
  metadataPool:
    replicated:
      size: 3
  dataPools:
    - replicated:
        size: 3
  preservePoolsOnDelete: true
  metadataServer:
    activeCount: 1
    activeStandby: true
---
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: rook-ceph-shared
# Change "rook-ceph" provisioner prefix to match the operator namespace if needed
provisioner: rook-ceph.cephfs.csi.ceph.com
parameters:
  # clusterID is the namespace where operator is deployed.
  clusterID: rook-ceph

  # CephFS filesystem name into which the volume shall be created
  fsName: rook-ceph-shared

  # Ceph pool into which the volume shall be created
  # Required for provisionVolume: "true"
  pool: rook-ceph-shared-data0

  # Root path of an existing CephFS volume
  # Required for provisionVolume: "false"
  # rootPath: /absolute/path

  # The secrets contain Ceph admin credentials. These are generated automatically by the operator
  # in the same namespace as the cluster.
  csi.storage.k8s.io/provisioner-secret-name: rook-csi-cephfs-provisioner
  csi.storage.k8s.io/provisioner-secret-namespace: rook-ceph
  csi.storage.k8s.io/controller-expand-secret-name: rook-csi-cephfs-provisioner
  csi.storage.k8s.io/controller-expand-secret-namespace: rook-ceph
  csi.storage.k8s.io/node-stage-secret-name: rook-csi-cephfs-node
  csi.storage.k8s.io/node-stage-secret-namespace: rook-ceph

reclaimPolicy: Delete
#+end_src

#+begin_src tmate :dir . :window cluster
kubectl apply -f ./rook-ceph-shared-pool-storageclass.yaml
#+end_src

#+begin_src yaml :tangle ./rook-ceph-pvc-shared-test.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: rook-ceph-pvc-shared-test
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 500Gi
  storageClassName: rook-ceph-shared
#+end_src

#+begin_src tmate :dir . :window cluster
kubectl -n default apply -f ./rook-ceph-pvc-shared-test.yaml
#+end_src

#+begin_src tmate :dir . :window cluster
kubectl -n default describe pvc rook-ceph-pvc-shared-test
#+end_src

#+begin_src yaml :tangle ./rook-ceph-dashboard.yaml
apiVersion: v1
kind: Service
metadata:
  name: rook-ceph-mgr-dashboard-external-https
  namespace: rook-ceph
  labels:
    app: rook-ceph-mgr
    rook_cluster: rook-ceph
spec:
  ports:
  - name: dashboard
    port: 8443
    protocol: TCP
    targetPort: 8443
  selector:
    app: rook-ceph-mgr
    rook_cluster: rook-ceph
  sessionAffinity: None
  type: NodePort
#+end_src

#+begin_src tmate :dir . :window cluster
kubectl apply -f ./rook-ceph-dashboard.yaml
#+end_src

#+begin_src tmate :dir . :window cluster
echo https://$(kubectl get node -o wide $(kubectl -n rook-ceph get pod -o wide | grep mgr | awk '{print $7}') | awk '{print $7}' | tail -1):$(kubectl -n rook-ceph get svc rook-ceph-mgr-dashboard-external-https -o=jsonpath='{.spec.ports[0].nodePort}')
echo admin :: $(kubectl -n rook-ceph get secrets rook-ceph-dashboard-password -o=jsonpath='{.data.password}' | base64 -d ; echo)
#+end_src

*** Debug
#+begin_src yaml :tangle ./rook-ceph-toolbox.yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: rook-ceph-tools
  namespace: rook-ceph
  labels:
    app: rook-ceph-tools
spec:
  selector:
    matchLabels:
      app: rook-ceph-tools
  template:
    metadata:
      labels:
        app: rook-ceph-tools
    spec:
      dnsPolicy: ClusterFirstWithHostNet
      containers:
      - name: rook-ceph-tools
        image: rook/ceph:v1.7.2
        command: ["/tini"]
        args: ["-g", "--", "/usr/local/bin/toolbox.sh"]
        imagePullPolicy: IfNotPresent
        env:
          - name: ROOK_CEPH_USERNAME
            valueFrom:
              secretKeyRef:
                name: rook-ceph-mon
                key: ceph-username
          - name: ROOK_CEPH_SECRET
            valueFrom:
              secretKeyRef:
                name: rook-ceph-mon
                key: ceph-secret
          - name: NODE_NAME
            valueFrom:
              fieldRef:
                fieldPath: spec.nodeName
        volumeMounts:
          - mountPath: /etc/ceph
            name: ceph-config
          - name: mon-endpoint-volume
            mountPath: /etc/rook
      volumes:
        - name: mon-endpoint-volume
          configMap:
            name: rook-ceph-mon-endpoints
            items:
            - key: data
              path: mon-endpoints
        - name: ceph-config
          emptyDir: {}
      tolerations:
        - key: "node.kubernetes.io/unreachable"
          operator: "Exists"
          effect: "NoExecute"
          tolerationSeconds: 5
#+end_src

#+begin_src tmate :dir . :window cluster
kubectl apply -f ./rook-ceph-toolbox.yaml
#+end_src

#+begin_src tmate :dir . :window cluster
kubectl -n rook-ceph exec -it daemonset/rook-ceph-tools -- bash
#+end_src

* Set up cluster apps

#+NAME: Get LoadBalancer IP
#+begin_src tmate :dir . :window cluster
export LOAD_BALANCER_IP=$(kubectl -n kube-system get cm kubeadm-config -o=jsonpath='{.data.ClusterConfiguration}' | yq e '.controlPlaneEndpoint' -P - | cut -d ':' -f1)
#+end_src

#+begin_src shell :results silent
curl -s -o postgres-operator-crd.yaml -L https://github.com/zalando/postgres-operator/raw/v1.7.0/manifests/postgresql.crd.yaml
curl -s -L https://github.com/zalando/postgres-operator/raw/v1.7.0/manifests/operator-service-account-rbac.yaml | sed 's/namespace: default/namespace: postgres-operator/g' > ./postgres-operator-serviceaccount.yaml
curl -s -o postgres-operator-apiservice.yaml -L https://github.com/zalando/postgres-operator/raw/v1.7.0/manifests/api-service.yaml
curl -s -o postgres-operator.yaml -L https://github.com/zalando/postgres-operator/raw/v1.7.0/manifests/postgres-operator.yaml
#+end_src

#+NAME: Postgres operator
#+begin_src yaml :tangle ./postgres-operator-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: postgres-operator
data:
  # additional_pod_capabilities: "SYS_NICE"
  # additional_secret_mount: "some-secret-name"
  # additional_secret_mount_path: "/some/dir"
  api_port: "8080"
  aws_region: eu-central-1
  cluster_domain: cluster.local
  cluster_history_entries: "1000"
  cluster_labels: application:spilo
  cluster_name_label: cluster-name
  # connection_pooler_default_cpu_limit: "1"
  # connection_pooler_default_cpu_request: "500m"
  # connection_pooler_default_memory_limit: 100Mi
  # connection_pooler_default_memory_request: 100Mi
  connection_pooler_image: "registry.opensource.zalan.do/acid/pgbouncer:master-18"
  # connection_pooler_max_db_connections: 60
  # connection_pooler_mode: "transaction"
  # connection_pooler_number_of_instances: 2
  # connection_pooler_schema: "pooler"
  # connection_pooler_user: "pooler"
  # custom_service_annotations: "keyx:valuez,keya:valuea"
  # custom_pod_annotations: "keya:valuea,keyb:valueb"
  db_hosted_zone: db.example.com
  debug_logging: "true"
  # default_cpu_limit: "1"
  # default_cpu_request: 100m
  # default_memory_limit: 500Mi
  # default_memory_request: 100Mi
  # delete_annotation_date_key: delete-date
  # delete_annotation_name_key: delete-clustername
  docker_image: registry.opensource.zalan.do/acid/spilo-13:2.1-p1
  # downscaler_annotations: "deployment-time,downscaler/*"
  # enable_admin_role_for_users: "true"
  # enable_crd_validation: "true"
  # enable_cross_namespace_secret: "false"
  # enable_database_access: "true"
  enable_ebs_gp3_migration: "false"
  # enable_ebs_gp3_migration_max_size: "1000"
  # enable_init_containers: "true"
  # enable_lazy_spilo_upgrade: "false"
  enable_master_load_balancer: "false"
  enable_pgversion_env_var: "true"
  enable_pod_antiaffinity: "true"
  enable_pod_disruption_budget: "true"
  # enable_postgres_team_crd: "false"
  # enable_postgres_team_crd_superusers: "false"
  enable_replica_load_balancer: "false"
  # enable_shm_volume: "true"
  # enable_sidecars: "true"
  enable_spilo_wal_path_compat: "true"
  enable_team_member_deprecation: "false"
  # enable_team_superuser: "false"
  enable_teams_api: "false"
  # etcd_host: ""
  external_traffic_policy: "Cluster"
  # gcp_credentials: ""
  # kubernetes_use_configmaps: "false"
  # infrastructure_roles_secret_name: "postgresql-infrastructure-roles"
  # infrastructure_roles_secrets: "secretname:monitoring-roles,userkey:user,passwordkey:password,rolekey:inrole"
  # inherited_annotations: owned-by
  # inherited_labels: application,environment
  # kube_iam_role: ""
  # log_s3_bucket: ""
  logical_backup_docker_image: "registry.opensource.zalan.do/acid/logical-backup:v1.7.0"
  # logical_backup_google_application_credentials: ""
  logical_backup_job_prefix: "logical-backup-"
  logical_backup_provider: "s3"
  # logical_backup_s3_access_key_id: ""
  logical_backup_s3_bucket: "my-bucket-url"
  # logical_backup_s3_region: ""
  # logical_backup_s3_endpoint: ""
  # logical_backup_s3_secret_access_key: ""
  logical_backup_s3_sse: "AES256"
  logical_backup_schedule: "30 00 * * *"
  major_version_upgrade_mode: "manual"
  master_dns_name_format: "{cluster}.{team}.{hostedzone}"
  # master_pod_move_timeout: 20m
  # max_instances: "-1"
  # min_instances: "-1"
  # min_cpu_limit: 250m
  # min_memory_limit: 250Mi
  # minimal_major_version: "9.5"
  # node_readiness_label: ""
  # oauth_token_secret_name: postgresql-operator
  # pam_configuration: |
  #  https://info.example.com/oauth2/tokeninfo?access_token= uid realm=/employees
  # pam_role_name: zalandos
  pdb_name_format: "postgres-{cluster}-pdb"
  pod_antiaffinity_topology_key: "kubernetes.io/hostname"
  pod_deletion_wait_timeout: 10m
  # pod_environment_configmap: "default/my-custom-config"
  # pod_environment_secret: "my-custom-secret"
  pod_label_wait_timeout: 10m
  pod_management_policy: "ordered_ready"
  # pod_priority_class_name: "postgres-pod-priority"
  pod_role_label: spilo-role
  # pod_service_account_definition: ""
  pod_service_account_name: "postgres-pod"
  # pod_service_account_role_binding_definition: ""
  pod_terminate_grace_period: 5m
  # postgres_superuser_teams: "postgres_superusers"
  # protected_role_names: "admin"
  ready_wait_interval: 3s
  ready_wait_timeout: 30s
  repair_period: 5m
  replica_dns_name_format: "{cluster}-repl.{team}.{hostedzone}"
  replication_username: standby
  resource_check_interval: 3s
  resource_check_timeout: 10m
  resync_period: 30m
  ring_log_lines: "100"
  role_deletion_suffix: "_deleted"
  secret_name_template: "{username}.{cluster}.credentials"
  # sidecar_docker_images: ""
  # set_memory_request_to_limit: "false"
  spilo_allow_privilege_escalation: "true"
  # spilo_runasuser: 101
  # spilo_runasgroup: 103
  # spilo_fsgroup: 103
  spilo_privileged: "false"
  storage_resize_mode: "pvc"
  super_username: postgres
  # target_major_version: "13"
  # team_admin_role: "admin"
  # team_api_role_configuration: "log_statement:all"
  # teams_api_url: http://fake-teams-api.default.svc.cluster.local
  # toleration: ""
  # wal_az_storage_account: ""
  # wal_gs_bucket: ""
  # wal_s3_bucket: ""
  watched_namespace: "*"  # listen to all namespaces
  workers: "8"
#+end_src

#+NAME: Install Postgres-Operator
#+begin_src tmate :dir . :window cluster
kubectl create ns postgres-operator 2> /dev/null
kubectl -n postgres-operator apply \
    -f ./postgres-operator-crd.yaml \
    -f ./postgres-operator-serviceaccount.yaml \
    -f ./postgres-operator-configmap.yaml \
    -f ./postgres-operator-apiservice.yaml \
    -f ./postgres-operator.yaml
kubectl -n postgres-operator wait pod --for=condition=Ready --selector=app.kubernetes.io/name=postgres-operator --timeout=200s
#+end_src

#+NAME: Cert-Manager
#+begin_src tmate :dir . :window cluster
curl -O -L https://github.com/jetstack/cert-manager/releases/download/v1.1.0/cert-manager.yaml
kubectl apply -f ./cert-manager.yaml
#+end_src

#+NAME: MetalLB
#+begin_src tmate :dir . :window cluster
kubectl get configmap kube-proxy -n kube-system -o yaml | sed -e "s/strictARP: false/strictARP: true/" | kubectl apply -f - -n kube-system
curl -o metallb-namespace.yaml -L https://raw.githubusercontent.com/metallb/metallb/v0.10.2/manifests/namespace.yaml
curl -O -L https://raw.githubusercontent.com/metallb/metallb/v0.10.2/manifests/metallb.yaml
kubectl apply -f ./metallb-namespace.yaml
kubectl apply -f ./metallb.yaml
kubectl create secret generic -n metallb-system memberlist --from-literal=secretkey="$(openssl rand -base64 128)"
#+end_src

#+NAME: Metrics-Server
#+begin_src yaml :tangle ./metrics-server.yaml
apiVersion: helm.fluxcd.io/v1
kind: HelmRelease
metadata:
  name: metrics-server
  namespace: kube-system
spec:
  releaseName: metrics-server
  chart:
    repository: https://olemarkus.github.io/metrics-server
    name: metrics-server
    version: 2.11.2
  values:
    args:
      - --logtostderr
      - --kubelet-preferred-address-types=InternalIP
      - --kubelet-insecure-tls
#+end_src

#+NAME: install metrics-server
#+begin_src tmate :dir . :window cluster
  kubectl apply -f ./metrics-server.yaml
#+end_src

#+NAME: nginx-ingress
#+begin_src yaml :tangle ./nginx-ingress.yaml
apiVersion: helm.fluxcd.io/v1
kind: HelmRelease
metadata:
  name: nginx-ingress
  namespace: nginx-ingress
spec:
  releaseName: nginx-ingress
  chart:
    repository: https://kubernetes.github.io/ingress-nginx
    name: ingress-nginx
    version: 4.0.3
  values:
    controller:
      ingressClassResource:
        default: true
      service:
        externalTrafficPolicy: Local
        annotations:
          metallb.universe.tf/allow-shared-ip: nginx-ingress
      publishService:
        enabled: true
      autoscaling:
        enabled: true
        minReplicas: 3
        maxReplicas: 5
        targetCPUUtilizationPercentage: 80
      minAvailable: 3
      metrics:
        enabled: true
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 1
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                  - key: app.kubernetes.io/name
                    operator: In
                    values:
                      - ingress-nginx
              topologyKey: "kubernetes.io/hostname"
#+end_src

#+NAME: install nginx-ingress
#+begin_src tmate :dir . :window cluster
kubectl create ns nginx-ingress
kubectl -n nginx-ingress apply -f ./nginx-ingress.yaml
#+end_src

Due to issues with Equinix Metal [CCM] + BGP IP addressing issues, the IP of the first node is used as the Ingress IP
#+begin_src tmate :dir . :window cluster
export K8S_NODE_IP=$(kubectl get nodes -o=jsonpath='{.items[0].status.addresses[1].address}')
kubectl -n nginx-ingress patch svc nginx-ingress-ingress-nginx-controller --type='json' -p="[{\"op\": \"replace\", \"path\": \"/spec/externalIPs/0\", \"value\":\"${K8S_NODE_IP}\"}]"
#+end_src

#+NAME: External-DNS manifests
#+begin_src yaml :tangle ./external-dns.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: external-dns
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRole
metadata:
  name: external-dns
rules:
- apiGroups:
    - ""
  resources:
    - services
    - endpoints
    - pods
  verbs:
    - get
    - watch
    - list
- apiGroups:
    - extensions
    - networking.k8s.io
  resources:
    - ingresses
  verbs:
    - get
    - watch
    - list
- apiGroups:
    - externaldns.k8s.io
  resources:
    - dnsendpoints
  verbs:
    - get
    - watch
    - list
- apiGroups:
    - externaldns.k8s.io
  resources:
    - dnsendpoints/status
  verbs:
  - get
  - update
  - patch
  - delete
---
apiVersion: rbac.authorization.k8s.io/v1beta1
kind: ClusterRoleBinding
metadata:
  name: external-dns-viewer
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: external-dns
subjects:
- kind: ServiceAccount
  name: external-dns
  namespace: external-dns
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: external-dns
spec:
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app: external-dns
  template:
    metadata:
      labels:
        app: external-dns
    spec:
      serviceAccountName: external-dns
      containers:
      - name: external-dns
        image: k8s.gcr.io/external-dns/external-dns:v0.7.4
        args:
        - --source=crd
        - --crd-source-apiversion=externaldns.k8s.io/v1alpha1
        - --crd-source-kind=DNSEndpoint
        - --provider=pdns
        - --policy=sync
        - --registry=txt
        - --interval=10s
        - --log-level=debug
        env:
          - name: EXTERNAL_DNS_TXT_OWNER_ID
            valueFrom:
              secretKeyRef:
                name: external-dns-pdns
                key: txt-owner-id
          - name: EXTERNAL_DNS_PDNS_SERVER
            valueFrom:
              secretKeyRef:
                name: external-dns-pdns
                key: pdns-server
          - name: EXTERNAL_DNS_PDNS_API_KEY
            valueFrom:
              secretKeyRef:
                name: external-dns-pdns
                key: pdns-api-key
          - name: EXTERNAL_DNS_PDNS_TLS_ENABLED
            value: "0"
#+end_src

#+NAME: External-DNS
#+begin_src tmate :dir . :window cluster
  kubectl create ns external-dns
  curl -o external-dns-crd.yaml -L https://raw.githubusercontent.com/kubernetes-sigs/external-dns/master/docs/contributing/crd-source/crd-manifest.yaml
  kubectl apply -f ./external-dns-crd.yaml
  kubectl -n external-dns create secret generic external-dns-pdns \
    --from-literal=txt-owner-id=gitlab \
    --from-literal=pdns-server=http://powerdns-service-api.powerdns:8081 \
    --from-literal=pdns-api-key=pairingissharing
  kubectl -n external-dns apply -f ./external-dns.yaml
#+end_src

#+NAME: PowerDNS
#+begin_src yaml :tangle powerdns.yaml
apiVersion: helm.fluxcd.io/v1
kind: HelmRelease
metadata:
  name: powerdns
spec:
  releaseName: powerdns
  chart:
    git: https://github.com/sharingio/helm-charts
    ref: master
    path: charts/powerdns
  values:
    domain: gitlab-staging.ii.coop
    default_soa_name: gitlab-staging.ii.coop
    apikey: pairingissharing
    powerdns:
      default_ttl: 3600
      soa_minimum_ttl: 3600
      domain: gitlab-staging.ii.coop
      default_soa_name: gitlab-staging.ii.coop
      mysql_host: powerdns-service-db
      mysql_user: powerdns
      extraEnv:
        - name: PDNS_dnsupdate
          value: "yes"
        - name: PDNS_allow_dnsupdate_from
          value: "192.168.0.0/24"
    service:
      dns:
        tcp:
          enabled: true
          annotations:
            metallb.universe.tf/allow-shared-ip: nginx-ingress
          externalIPs:
            - ${LOAD_BALANCER_IP}
        udp:
          annotations:
            metallb.universe.tf/allow-shared-ip: nginx-ingress
          externalIPs:
            - ${LOAD_BALANCER_IP}
    mariadb:
      mysql_pass: pairingissharing
      mysql_rootpass: pairingissharing
    admin:
      enabled: false
      ingress:
        enabled: false
      secret: pairingissharing
#+end_src

#+NAME: install PowerDNS
#+begin_src tmate :dir . :window cluster
  kubectl create ns powerdns
  envsubst < ./powerdns.yaml | kubectl -n powerdns apply -f -
#+end_src

#+NAME: PowerDNS configure
#+begin_src tmate :dir . :window cluster
  kubectl -n powerdns wait pod --for=condition=Ready --selector=app.kubernetes.io/name=powerdns --timeout=200s
  until [ "$(dig A ns1.gitlab-staging.ii.coop +short)" = "${LOAD_BALANCER_IP}" ]; do
    echo "BaseDNSName does not resolve to Instance IP yet"
    sleep 1
  done
  kubectl -n powerdns exec deployment/powerdns -- pdnsutil generate-tsig-key pair hmac-md5
  kubectl -n powerdns exec deployment/powerdns -- pdnsutil activate-tsig-key gitlab-staging.ii.coop pair master
  kubectl -n powerdns exec deployment/powerdns -- pdnsutil set-meta gitlab-staging.ii.coop TSIG-ALLOW-DNSUPDATE pair
  kubectl -n powerdns exec deployment/powerdns -- pdnsutil set-meta gitlab-staging.ii.coop NOTIFY-DNSUPDATE 1
  kubectl -n powerdns exec deployment/powerdns -- pdnsutil set-meta gitlab-staging.ii.coop SOA-EDIT-DNSUPDATE EPOCH
  export POWERDNS_TSIG_SECRET="$(kubectl -n powerdns exec deployment/powerdns -- pdnsutil list-tsig-keys | grep pair | awk '{print $3}' | tr -d '\n')"
  nsupdate <<EOF
  server ${LOAD_BALANCER_IP} 53
  zone gitlab-staging.ii.coop
  update add gitlab-staging.ii.coop 60 NS ns1.gitlab-staging.ii.coop
  key pair ${POWERDNS_TSIG_SECRET}
  send
  EOF
  kubectl -n cert-manager create secret generic tsig-powerdns --from-literal=powerdns="$POWERDNS_TSIG_SECRET"
  kubectl -n powerdns create secret generic tsig-powerdns --from-literal=powerdns="$POWERDNS_TSIG_SECRET"
#+end_src

#+NAME: DNSEndpoint
#+begin_src yaml :tangle ./dnsendpoint.yaml
apiVersion: externaldns.k8s.io/v1alpha1
kind: DNSEndpoint
metadata:
  name: gitlab-ii-coop
spec:
  endpoints:
  - dnsName: 'gitlab-staging.ii.coop'
    recordTTL: 3600
    recordType: A
    targets:
    - ${LOAD_BALANCER_IP}
  - dnsName: '*.gitlab-staging.ii.coop'
    recordTTL: 3600
    recordType: A
    targets:
    - ${LOAD_BALANCER_IP}
  - dnsName: gitlab-staging.ii.coop
    recordTTL: 3600
    recordType: SOA
    targets:
    - 'ns1.gitlab-staging.ii.coop. hostmaster.gitlab-staging.ii.coop. 5 3600 3600 3600 3600'
#+end_src

#+begin_src tmate :dir . :window cluster
  envsubst < dnsendpoint.yaml | kubectl -n powerdns apply -f -
#+end_src

#+NAME: kubed
#+begin_src yaml :tangle ./kubed.yaml
apiVersion: helm.fluxcd.io/v1
kind: HelmRelease
metadata:
  name: kubed
  namespace: kube-system
spec:
  releaseName: kubed
  chart:
    repository: https://charts.appscode.com/stable/
    name: kubed
    version: v0.12.0
  values:
    enableAnalytics: false
#+end_src

#+begin_src tmate :dir . :window cluster
  kubectl apply -f ./kubed.yaml
#+end_src

#+NAME: Humacs-PVC
#+begin_src yaml :tangle ./humacs-pvc.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: humacs-home-ii
  namespace: humacs
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 500Gi
  storageClassName: rook-ceph-block
#+end_src

#+begin_src tmate :dir . :window cluster
  kubectl create ns humacs
  kubectl -n humacs apply -f ./humacs-pvc.yaml
#+end_src

#+NAME: Humacs
#+begin_src yaml :tangle ./humacs.yaml
apiVersion: helm.fluxcd.io/v1
kind: HelmRelease
metadata:
  name: humacs
  namespace: humacs
spec:
  releaseName: humacs
  chart:
    git: https://github.com/humacs/humacs
    ref: main
    path: chart/humacs
  values:
    options:
      hostDockerSocket: false
      hostTmp: true
      timezone: Pacific/Auckland
      gitName: gitlab
      gitEmail: humacs@ii.coop
      profile: ii
    image:
      repository: registry.gitlab.com/humacs/humacs/ii
      tag: 2020.12.03
    extraEnvVars:
      - name: HUMACS_DEBUG
        value: "true"
      - name: REINIT_HOME_FOLDER
        value: "true"
    extraVolumes:
      - name: home-ii
        persistentVolumeClaim:
          claimName: humacs-home-ii
    extraVolumeMounts:
      - name: home-ii
        mountPath: "/home/ii"
#+end_src

#+begin_src tmate :dir . :window cluster
  kubectl apply -f ./humacs.yaml
#+end_src

* Install GitLab
#+NAME: Create GitLab namespace
#+begin_src tmate :dir . :window cluster
kubectl create ns gitlab
#+end_src

#+NAME: Certs
#+begin_src yaml :tangle ./certs.yaml
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt-prod
spec:
  acme:
    server: https://acme-v02.api.letsencrypt.org/directory
    email: letsencrypt@ii.coop
    privateKeySecretRef:
      name: letsencrypt-prod
    solvers:
    - http01:
        ingress:
          class: nginx
---
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: letsencrypt-prod
spec:
  secretName: letsencrypt-prod
  issuerRef:
    name: letsencrypt-prod
    kind: ClusterIssuer
  dnsNames:
    - "gitlab.ii.coop"
    - "minio.gitlab.ii.coop"
    - "registry.gitlab.ii.coop"
#+end_src

#+begin_src tmate :dir . :window cluster
envsubst < certs.yaml | kubectl -n gitlab apply -f -
#+end_src

#+NAME: Postgres database
#+begin_src yaml :tangle ./gitlab-postgres.yaml
apiVersion: "acid.zalan.do/v1"
kind: postgresql
metadata:
  name: gitlab-db
  namespace: gitlab
spec:
  enableConnectionPooler: true
  connectionPooler:
    mode: session
    resources:
      requests:
        cpu: 250m
        memory: 100Mi
      limits:
        cpu: "1"
        memory: 100Mi
  teamId: "gitlab"
  volume:
    size: 50Gi
  numberOfInstances: 3
  users:
    gitlab:  # database owner
    - superuser
    - createdb
  databases:
    gitlab: gitlab  # dbname: owner
  postgresql:
    version: "13"
#+end_src

#+NAME: Install Postgres database
#+begin_src tmate :dir . :window cluster
kubectl -n gitlab apply -f gitlab-postgres.yaml
#+end_src

#+NAME: .example.env
#+begin_src tmate :dir . :window cluster
read -p 'GITLAB_IMAP_PASSWORD: ' GITLAB_IMAP_PASSWORD && export GITLAB_IMAP_PASSWORD \
read -p 'GITLAB_SMTP_PASSWORD: ' GITLAB_SMTP_PASSWORD && export GITLAB_SMTP_PASSWORD \
read -p 'GITLAB_OMNIAUTH_GITHUB_APP_ID: ' GITLAB_OMNIAUTH_GITHUB_APP_ID && export GITLAB_OMNIAUTH_GITHUB_APP_ID \
read -p 'GITLAB_OMNIAUTH_GITHUB_APP_SECRET: ' GITLAB_OMNIAUTH_GITHUB_APP_SECRET && export GITLAB_OMNIAUTH_GITHUB_APP_SECRET \
read -p 'GITLAB_OMNIAUTH_GITLAB_APP_ID: ' GITLAB_OMNIAUTH_GITLAB_APP_ID && export GITLAB_OMNIAUTH_GITLAB_APP_ID \
read -p 'GITLAB_OMNIAUTH_GITLAB_APP_SECRET: ' GITLAB_OMNIAUTH_GITLAB_APP_SECRET && export GITLAB_OMNIAUTH_GITLAB_APP_SECRET \
read -p 'GITLAB_OMNIAUTH_GOOGLE_APP_ID: ' GITLAB_OMNIAUTH_GOOGLE_APP_ID && export GITLAB_OMNIAUTH_GOOGLE_APP_ID \
read -p 'GITLAB_OMNIAUTH_GOOGLE_APP_SECRET: ' GITLAB_OMNIAUTH_GOOGLE_APP_SECRET && export GITLAB_OMNIAUTH_GOOGLE_APP_SECRET \
read -p 'GITLAB_OMNIAUTH_FACEBOOK_APP_ID: ' GITLAB_OMNIAUTH_FACEBOOK_APP_ID && export GITLAB_OMNIAUTH_FACEBOOK_APP_ID \
read -p 'GITLAB_OMNIAUTH_FACEBOOK_APP_SECRET: ' GITLAB_OMNIAUTH_FACEBOOK_APP_SECRET && export GITLAB_OMNIAUTH_FACEBOOK_APP_SECRET \
read -p 'GITLAB_OMNIAUTH_TWITTER_APP_ID: ' GITLAB_OMNIAUTH_TWITTER_APP_ID && export GITLAB_OMNIAUTH_TWITTER_APP_ID \
read -p 'GITLAB_OMNIAUTH_TWITTER_APP_SECRET: ' GITLAB_OMNIAUTH_TWITTER_APP_SECRET
#+end_src

#+NAME: imap password
#+begin_src tmate :dir . :window cluster
kubectl -n gitlab create secret generic gitlab-ii-coop-imap-password --from-literal=password="$GITLAB_IMAP_PASSWORD" -o yaml --dry-run | kubectl apply -f -
#+end_src

#+NAME: smtp password
#+begin_src tmate :dir . :window cluster
kubectl -n gitlab create secret generic gitlab-ii-coop-smtp-password --from-literal=password="$GITLAB_SMTP_PASSWORD" -o yaml --dry-run | kubectl apply -f -
#+end_src

#+NAME: omniauth provider github
#+begin_src tmate :dir . :window cluster
kubectl -n gitlab create secret generic gitlab-ii-coop-omniauth-github --from-literal=provider="$(envsubst <<EOF
name: github
app_id: '${GITLAB_OMNIAUTH_GITHUB_APP_ID}'
app_secret: '${GITLAB_OMNIAUTH_GITHUB_APP_SECRET}'
url: https://github.com/
args:
  scope: 'user:email'
EOF
)" -o yaml --dry-run | kubectl apply -f -
#+end_src

#+NAME: omniauth provider gitlab
#+begin_src tmate :dir . :window cluster
kubectl -n gitlab create secret generic gitlab-ii-coop-omniauth-gitlab --from-literal=provider="$(envsubst <<EOF
name: gitlab
app_id: '${GITLAB_OMNIAUTH_GITLAB_APP_ID}'
app_secret: '${GITLAB_OMNIAUTH_GITLAB_APP_SECRET}'
args:
  scope: 'api'
EOF
)" -o yaml --dry-run | kubectl apply -f -
#+end_src

#+NAME: omniauth provider google_oauth2
#+begin_src tmate :dir . :window cluster
kubectl -n gitlab create secret generic gitlab-ii-coop-omniauth-google-oauth2 --from-literal=provider="$(envsubst <<EOF
name: google_oauth2
app_id: '${GITLAB_OMNIAUTH_GOOGLE_APP_ID}'
app_secret: '${GITLAB_OMNIAUTH_GOOGLE_APP_SECRET}'
args:
  access_type: offline
  approval_prompt: ''
EOF
)" -o yaml --dry-run | kubectl apply -f -
#+end_src

#+NAME: omniauth provider twitter
#+begin_src tmate :dir . :window cluster
kubectl -n gitlab create secret generic gitlab-ii-coop-omniauth-twitter --from-literal=provider="$(envsubst <<EOF
name: twitter
app_id: '${GITLAB_OMNIAUTH_TWITTER_APP_ID}'
app_secret: '${GITLAB_OMNIAUTH_TWITTER_APP_SECRET}'
EOF
)" -o yaml --dry-run | kubectl apply -f -
#+end_src

#+NAME: GitLab
#+begin_src yaml :tangle ./gitlab.yaml
apiVersion: helm.fluxcd.io/v1
kind: HelmRelease
metadata:
  name: gitlab
spec:
  releaseName: gitlab
  chart:
    repository: https://charts.gitlab.io/
    name: gitlab
    version: 5.1.6
  values:
    postgresql:
      install: false
    global:
      psql:
        host: gitlab-db-pooler.gitlab
        password:
          secret: gitlab.gitlab-db.credentials
          key: password
        port: 5432
        database: gitlab
        username: gitlab
      email:
        from: gitlab@ii.coop
        reply_to: gitlab@ii.coop
        display_name: gitlab.ii.coop
      appConfig:
        incomingEmail:
          enabled: true
          address: '%{key}@gitlab.ii.coop'
          user: mailbot@ii.coop
          host: imap.gmail.com
          port: 993
          ssl: true
          startTls: false
          idleTimeout: 60
          password:
            secret: gitlab-ii-coop-imap-password
            key: password
        omniauth:
          enabled: true
          blockAutoCreatedUsers: true
          allowSingleSignOn:
            - twitter
            - github
            - google_oauth2
            - gitlab
            - facebook
          providers:
            - secret: gitlab-ii-coop-omniauth-github
            - secret: gitlab-ii-coop-omniauth-gitlab
            - secret: gitlab-ii-coop-omniauth-google-oauth2
            - secret: gitlab-ii-coop-omniauth-twitter
      smtp:
        enabled: true
        address: smtp.gmail.com
        authentication: login
        openssl_verify_mode: peer
        tls: false
        starttls_auto: true
        domain: gitlab.ii.coop
        port: 587
        user_name: mailbot@ii.coop
        password:
          secret: gitlab-ii-coop-smtp-password
          key: password
      hosts:
        domain: ii.coop
        gitlab:
          name: gitlab.ii.coop
        minio:
          name: minio.gitlab.ii.coop
        registry:
          name: registry.gitlab.ii.coop
      ingress:
        configureCertmanager: false
      pages:
        enabled: true
        global:
          hosts:
            domain: gitlab.ii.coop
        host: gitlab.ii.coop
        port: 443
        https: true
        apiSecret:
          secret: gitlab-pages-api-secret
          key: shared_secret
      shell:
        port: 22
    certmanager:
      install: false
    gitlab:
      ingress:
        enabled: true
      ingressclass: nginx
      gitlab-shell:
        enabled: true
        service:
          annotations:
            metallb.universe.tf/allow-shared-ip: nginx-ingress
          type: LoadBalancer
      webservice:
        ingress:
          annotations:
            kubernetes.io/ingress.class: nginx
          tls:
            secretName: letsencrypt-prod
      task-runner:
        enabled: true
        replicas: 1
        persistence:
          enabled: true
          size: '120Gi'
    gitlab-pages:
      enabled: true
      ingress:
        enabled: true
        annotations:
          kubernetes.io/ingress.class: nginx
        tls:
          secretName: letsencrypt-prod
    registry:
      ingress:
        annotations:
          kubernetes.io/ingress.class: nginx
        tls:
          secretName: letsencrypt-prod
    minio:
      ingress:
        annotations:
          kubernetes.io/ingress.class: nginx
        tls:
          secretName: letsencrypt-prod
    nginx-ingress:
      enabled: false
    task-runner:
      enabled: true
      replicas: 1
      persistence:
        enabled: true
        size: '120Gi'
#+end_src

#+begin_src tmate :dir . :window cluster
kubectl -n gitlab apply -f ./gitlab.yaml
#+end_src

** Finalising
Due to issues with Equinix Metal [CCM] + BGP IP addressing issues, the IP of the first node is used as the Ingress IP
#+begin_src tmate :dir . :window cluster
export K8S_NODE_IP=$(kubectl get nodes -o=jsonpath='{.items[0].status.addresses[1].address}')
kubectl -n gitlab patch svc gitlab-gitlab-shell --type='json' -p="[{\"op\": \"replace\", \"path\": \"/spec/externalIPs/0\", \"value\":\"${K8S_NODE_IP}\"}]"
#+end_src

** Migration

[[https://docs.gitlab.com/charts/installation/version_mappings.html][Helm migration path]] ([[https://docs.gitlab.com/ee/update/#upgrade-paths][Upgrade path]]):
- Helm Chart v4.7.2 (GitLab v13.7.2)
- Helm Chart v4.8.8 (GitLab v13.8.8)
- Helm Chart v4.12.12 (GitLab v13.12.12)
- Helm Chart v5.0.0 (GitLab v14.0.0)
- Helm Chart v5.1.6 (GitLab v14.1.6)
- Helm Chart v5.2.0 (GitLab v14.2.0)
- Helm Chart v5.2.4 (GitLab v14.2.4)
- Helm Chart v5.3.0 (GitLab v14.3.0)

Get MinIO Access and Secret keys
#+begin_src tmate :window cluster
(
  echo 'ACCESSKEY | SECRETKEY'
  echo $(kubectl -n gitlab get secret gitlab-minio-secret -o=jsonpath='{.data.accesskey}' | base64 -d ; echo) \| $(kubectl -n gitlab get secret gitlab-minio-secret -o=jsonpath='{.data.secretkey}' | base64 -d ); echo
) | column -t
#+end_src

Configure =/etc/gitlab/gitlab.rb=
#+begin_src ruby
gitlab_rails['artifacts_object_store_enabled'] = true
gitlab_rails['artifacts_object_store_remote_directory'] = "artifacts"
gitlab_rails['artifacts_object_store_connection'] = {
  'provider' => 'AWS',
  'region' => 'us-east-1',
  'aws_access_key_id' => '',
  'aws_secret_access_key' => '',
  'host' => 'minio.gitlab-staging.ii.coop',
  'endpoint' => 'https://minio.gitlab-staging.ii.coop'
}

gitlab_rails['uploads_object_store_enabled'] = true
gitlab_rails['uploads_object_store_remote_directory'] = "uploads"
gitlab_rails['uploads_object_store_connection'] = {
  'provider' => 'AWS',
  'region' => 'us-east-1',
  'aws_access_key_id' => '',
  'aws_secret_access_key' => '',
  'endpoint' => 'https://minio.gitlab-staging.ii.coop',
  'host' => 'minio.gitlab-staging.ii.coop',
}

gitlab_rails['lfs_object_store_enabled'] = true
gitlab_rails['lfs_object_store_remote_directory'] = "lfs-objects"
gitlab_rails['lfs_object_store_connection'] = {
  'provider' => 'AWS',
  'region' => 'us-east-1',
  'aws_access_key_id' => '',
  'aws_secret_access_key' => '',
  'endpoint' => 'https://minio.gitlab-staging.ii.coop',
  'host' => 'minio.gitlab-staging.ii.coop',
  'path_style' => true
}
#+end_src
filling in the =aws_access_key_id= and =aws_secret_access_key= fields with the MinIO access keys

#+begin_src shell
# update the settings
gitlab-ctl reconfigure

# migrate LFS to new instance
gitlab-rake gitlab:lfs:migrate

# migrate all uploads to the new instance
gitlab-rake gitlab:uploads:migrate:all

# create a backup of all the data
gitlab-rake gitlab:backup:create SKIP=artifacts,lfs,uploads
#+end_src

Prepare a /gitlab-rails-secret/ based off of the =/etc/gitlab/gitlab-secrets.rb= file
#+begin_src tmate :window cluster
read -p 'db_key_base: ' db_key_base && export db_key_base && \
read -p 'secret_key_base: ' secret_key_base && export secret_key_base && \
read -p 'otp_key_base: ' otp_key_base && export otp_key_base && \
read -p 'encrypted_settings_key_base: ' encrypted_settings_key_base && export encrypted_settings_key_base && \
echo "Place the existing 'openid_connect_signing_key' contents in the field" && \
echo "Place the existing 'ci_jwt_signing_key' contents in the field" && \
cat << EOF > /tmp/gitlab-rails-secrets.yml
production:
  db_key_base: $db_key_base
  secret_key_base: $secret_key_base
  otp_key_base: $otp_key_base
  encrypted_settings_key_base: $encrypted_settings_key_base
  ci_jwt_signing_key: |

  openid_connect_signing_key: |

EOF
#+end_src
Edit //tmp/gitlab-rails-secrets.yml/ to include the remaining certificates

Update the rails-secret
#+begin_src tmate :window cluster
kubectl -n gitlab create secret generic gitlab-rails-secret --from-file=secrets.yml=/tmp/gitlab-rails-secrets.yml -o yaml --dry-run=client \
  | kubectl apply -f -
#+end_src

Get new Pods that know about the secret
#+begin_src tmate :window cluster
kubectl -n gitlab rollout restart $(kubectl -n gitlab get deployment -o=jsonpath='{range .items[*]}deployment/{.metadata.name} {end}' | grep -E 'sidekiq|webservice|task-runner')
#+end_src

(on existing GitLab instance)
#+begin_src shell
docker-compose exec gitlab.ii.coop bash

cd /var/opt/gitlab/backups/

# find the latest backup file
GITLAB_BACKUP_FILE=$(realpath $(ls /var/opt/gitlab/backups/ | grep $(date +%m_%d)))
cp $GITLAB_BACKUP_FILE /tmp/gitlab_backup.tar

exit

# copy out of the container
docker cp $(docker ps | grep gitlab.ii.coop | awk '{print $1}'):/tmp/gitlab_backup.tar /tmp/gitlab_backup.tar
#+end_src

Copy the backup onto this host
#+begin_src tmate :window cluster
scp root@147.75.69.207:/tmp/gitlab_backup.tar /tmp/gitlab_backup.tar
#+end_src

Copy the backup into the task-runner Pod
#+begin_src tmate :window cluster
export TASK_RUNNER_POD_NAME=$(kubectl -n gitlab get pods -l app=task-runner -o=jsonpath='{.items[0].metadata.name}')
kubectl -n gitlab cp -c task-runner /tmp/gitlab_backup.tar $(kubectl -n gitlab get pods -l app=task-runner -o=jsonpath='{.items[0].metadata.name}'):/tmp/gitlab_backup.tar
#+end_src

Drop the /pg_stat_statements/ extension
#+begin_src tmate :window cluster
POSTGRES_PASSWORD="$(kubectl -n gitlab get secret gitlab.gitlab-db.credentials -o=jsonpath='{.data.password}' | base64 -d)"
kubectl -n gitlab exec -it deployment/gitlab-db-pooler -- psql "postgres://gitlab:$POSTGRES_PASSWORD@gitlab-db-pooler:5432/gitlab?sslmode=require" -c 'drop extension pg_stat_statements cascade;'
#+end_src

Restore the backup
#+begin_src tmate :window cluster
kubectl -n gitlab exec -c task-runner -it $TASK_RUNNER_POD_NAME -- backup-utility --restore -f file:///tmp/gitlab_backup.tar
#+end_src

Enable Kubernetes features
#+begin_src tmate :window cluster
kubectl -n gitlab exec -c task-runner -it $TASK_RUNNER_POD_NAME -- gitlab-rails runner -e production /scripts/custom-instance-setup
#+end_src

Get new Pods, after restoring from the backup
#+begin_src tmate :window cluster
kubectl -n gitlab rollout restart $(kubectl -n gitlab get deployment -o=jsonpath='{range .items[*]}deployment/{.metadata.name} {end}' | tr ' ' '\n' | grep -E 'sidekiq|webservice')
#+end_src

** Debug
Jump into the database
#+begin_src tmate :window cluster
POSTGRES_PASSWORD="$(kubectl -n gitlab get secret gitlab.gitlab-db.credentials -o=jsonpath='{.data.password}' | base64 -d)"
kubectl -n gitlab exec -it deployment/gitlab-db-pooler -- psql "postgres://gitlab:$POSTGRES_PASSWORD@gitlab-db-pooler:5432/gitlab?sslmode=require"
#+end_src

View the rendered manifests
#+begin_src tmate :window cluster
helm repo add gitlab https://charts.gitlab.io/
helm repo update
helm template -n gitlab gitlab gitlab/gitlab --version 5.1.5 -f <(helm get values -n gitlab gitlab -o yaml | cat 2> /dev/null)
#+end_src

If Helm-Operator is not liking upgrading, very occasionally manual upgrading is needed
#+begin_src tmate :window cluster
helm upgrade --install -n gitlab gitlab gitlab/gitlab --version 5.0.0 -f <(helm get values -n gitlab gitlab -o yaml | cat 2> /dev/null)
#+end_src

Ensure that background jobs have completed before continuing in a migration
#+begin_src tmate :window cluster
export TASK_RUNNER_POD_NAME=$(kubectl -n gitlab get pods -l app=task-runner -o=jsonpath='{.items[0].metadata.name}')
kubectl -n gitlab exec -c task-runner -it $TASK_RUNNER_POD_NAME -- gitlab-rake gitlab:background_migrations:finalize[CopyColumnUsingBackgroundMigrationJob,push_event_payloads,event_id,'[["event_id"]\, ["event_id_convert_to_bigint"]]']
#+end_src

** TODO
- ensure that the /gitlab-gitlab-shell/ Service in the /gitlab/ Namespace has the same LoadBalancerIP as the /nginx-ingress-ingress-nginx-controller/ in the /nginx-ingress/ Namespace
  https://metallb.universe.tf/usage/

** References
- https://docs.gitlab.com/charts/installation/migration/package_to_helm.html
- https://docs.gitlab.com/charts/backup-restore/restore.html
- https://docs.gitlab.com/ee/administration/object_storage.html#connection-settings

* Install Mattermost

#+begin_src tmate :dir . :window cluster
kubectl create namespace mattermost -o yaml --dry-run=client | \
    kubectl apply -f -
#+end_src

** Install Postgresql-HA
#+name: postgres-database
#+begin_src yaml :tangle ./mattermost-postgresql.yaml
apiVersion: "acid.zalan.do/v1"
kind: postgresql
metadata:
  name: mattermost-db
spec:
  enableConnectionPooler: true
  connectionPooler:
    mode: session
    resources:
      requests:
        cpu: 250m
        memory: 100Mi
      limits:
        cpu: "1"
        memory: 100Mi
  teamId: "mattermost"
  volume:
    size: 50Gi
  numberOfInstances: 3
  users:
    mattermost:  # database owner
    - superuser
    - createdb
  databases:
    mattermost: mattermost  # dbname: owner
  postgresql:
    version: "13"
#+end_src

#+name: install-postgres-database
#+begin_src tmate :dir . :window cluster
kubectl -n mattermost apply -f ./mattermost-postgresql.yaml
#+end_src

** Install MinIO Operator
Create the namespace:
#+name: create-minio-namespace
#+begin_src tmate :dir . :window cluster
kubectl create ns minio-operator
#+end_src

Download the latest manifests:
#+name: download-minio-operator-manifests
#+begin_src tmate :dir . :window cluster
curl -O -L https://raw.githubusercontent.com/mattermost/mattermost-operator/v1.14.0/docs/minio-operator/minio-operator.yaml
#+end_src

Install the operator:
#+name: install-minio-operator
#+begin_src tmate :dir . :window cluster
kubectl -n minio-operator apply -f ./minio-operator.yaml
#+end_src

** Install Mattermost Operator
Create the namespace:
#+name: create-mattermost-operator-namespace
#+begin_src tmate :dir . :window cluster
kubectl create ns mattermost-operator
#+end_src

Download the latest manifests:
#+name: download-mattermost-operator-manifests
#+begin_src tmate :dir . :window cluster
curl -O -L https://raw.githubusercontent.com/mattermost/mattermost-operator/v1.14.0/docs/mattermost-operator/mattermost-operator.yaml
#+end_src

Install the operator:
#+name: install-mattermost-operator
#+begin_src tmate :dir . :window cluster
kubectl apply -n mattermost-operator -f ./mattermost-operator.yaml
#+end_src

** Install Mattermost
*** Add OAuth secret
#+begin_src tmate :window cluster
read -p 'MM_GITLABSETTINGS_ID: ' MM_GITLABSETTINGS_ID && export MM_GITLABSETTINGS_ID && \
read -p 'MM_GITLABSETTINGS_SECRET: ' MM_GITLABSETTINGS_SECRET && export MM_GITLABSETTINGS_SECRET && \
read -p 'MM_GITLABSETTINGS_SCOPE: ' MM_GITLABSETTINGS_SCOPE && export MM_GITLABSETTINGS_SCOPE && \
read -p 'MM_GITLABSETTINGS_AUTHENDPOINT: ' MM_GITLABSETTINGS_AUTHENDPOINT && export MM_GITLABSETTINGS_AUTHENDPOINT && \
read -p 'MM_GITLABSETTINGS_TOKENENDPOINT: ' MM_GITLABSETTINGS_TOKENENDPOINT && export MM_GITLABSETTINGS_TOKENENDPOINT && \
read -p 'MM_GITLABSETTINGS_USERAPIENDPOINT: ' MM_GITLABSETTINGS_USERAPIENDPOINT && export MM_GITLABSETTINGS_USERAPIENDPOINT && \
read -p 'MM_EMAILSETTINGS_ENABLESIGNINWITHEMAIL: ' MM_EMAILSETTINGS_ENABLESIGNINWITHEMAIL && export MM_EMAILSETTINGS_ENABLESIGNINWITHEMAIL && \
read -p 'MM_EMAILSETTINGS_ENABLESIGNINWITHUSERNAME: ' MM_EMAILSETTINGS_ENABLESIGNINWITHUSERNAME && export MM_EMAILSETTINGS_ENABLESIGNINWITHUSERNAME && \
read -p 'MM_EMAILSETTINGS_FEEDBACKNAME: ' MM_EMAILSETTINGS_FEEDBACKNAME && export MM_EMAILSETTINGS_FEEDBACKNAME && \
read -p 'MM_EMAILSETTINGS_SMTPUSERNAME: ' MM_EMAILSETTINGS_SMTPUSERNAME && export MM_EMAILSETTINGS_SMTPUSERNAME && \
read -p 'MM_EMAILSETTINGS_SMTPPASSWORD: ' MM_EMAILSETTINGS_SMTPPASSWORD && export MM_EMAILSETTINGS_SMTPPASSWORD && \
read -p 'MM_EMAILSETTINGS_SMTPSERVER: ' MM_EMAILSETTINGS_SMTPSERVER && export MM_EMAILSETTINGS_SMTPSERVER && \
read -p 'MM_EMAILSETTINGS_SMTPPORT: ' MM_EMAILSETTINGS_SMTPPORT && export MM_EMAILSETTINGS_SMTPPORT && \
read -p 'MM_EMAILSETTINGS_CONNECTIONSECURITY: ' MM_EMAILSETTINGS_CONNECTIONSECURITY && export MM_EMAILSETTINGS_CONNECTIONSECURITY && \
kubectl -n mattermost create secret generic mattermost-user-config \
    --from-literal=MM_GITLABSETTINGS_ID="$MM_GITLABSETTINGS_ID" \
    --from-literal=MM_GITLABSETTINGS_SECRET="$MM_GITLABSETTINGS_SECRET" \
    --from-literal=MM_GITLABSETTINGS_AUTHENDPOINT="$MM_GITLABSETTINGS_AUTHENDPOINT" \
    --from-literal=MM_GITLABSETTINGS_TOKENENDPOINT="$MM_GITLABSETTINGS_TOKENENDPOINT" \
    --from-literal=MM_GITLABSETTINGS_USERAPIENDPOINT="$MM_GITLABSETTINGS_USERAPIENDPOINT" \
    --from-literal=MM_EMAILSETTINGS_ENABLESIGNINWITHEMAIL="$MM_EMAILSETTINGS_ENABLESIGNINWITHEMAIL" \
    --from-literal=MM_EMAILSETTINGS_ENABLESIGNINWITHUSERNAME="$MM_EMAILSETTINGS_ENABLESIGNINWITHUSERNAME" \
    --from-literal=MM_EMAILSETTINGS_FEEDBACKNAME="$MM_EMAILSETTINGS_FEEDBACKNAME" \
    --from-literal=MM_EMAILSETTINGS_SMTPUSERNAME="$MM_EMAILSETTINGS_SMTPUSERNAME" \
    --from-literal=MM_EMAILSETTINGS_SMTPPASSWORD="$MM_EMAILSETTINGS_SMTPPASSWORD" \
    --from-literal=MM_EMAILSETTINGS_SMTPSERVER="$MM_EMAILSETTINGS_SMTPSERVER" \
    --from-literal=MM_EMAILSETTINGS_SMTPPORT="$MM_EMAILSETTINGS_SMTPPORT" \
    --from-literal=MM_EMAILSETTINGS_CONNECTIONSECURITY="$MM_EMAILSETTINGS_CONNECTIONSECURITY" \
    -o yaml --dry-run=client \
    | kubectl apply -f -
#+end_src

*** Operator configuration
#+name: mattermost-cluster-definition
#+begin_src yaml :tangle ./mattermost.yaml
apiVersion: installation.mattermost.com/v1beta1
kind: Mattermost
metadata:
  name: mattermost # Name of your cluster as shown in Kubernetes.
  namespace: mattermost
spec:
  database:
    external:
      secret: mattermost-database
  elasticSearch: {}
  fileStore:
    operatorManaged:
      replicas: 1
      resources:
        requests:
          cpu: 150m
          memory: 512Mi
      storageSize: 50Gi
  image: mattermost/mattermost-enterprise-edition
  imagePullPolicy: IfNotPresent
  ingressAnnotations:
    kubernetes.io/ingress.class: nginx
  ingressName: mattermost.ii.coop
  probes:
    livenessProbe: {}
    readinessProbe: {}
  replicas: 1
  scheduling:
    affinity: {}
    resources:
      limits:
        cpu: "2"
        memory: 4Gi
      requests:
        cpu: 150m
        memory: 256Mi
  useIngressTLS: true
  version: "5.39"
  mattermostEnv:
    - name: MM_GITLABSETTINGS_ENABLE
      value: "true"
    - name: MM_EMAILSETTINGS_ENABLESIGNINWITHEMAIL
      value: "true"
    - name: MM_EMAILSETTINGS_ENABLESIGNINWITHUSERNAME
      value: "true"
    - name: MM_EMAILSETTINGS_SENDEMAILNOTIFICATIONS
      value: "true"
    - name: MM_EMAILSETTINGS_REQUIREEMAILVERIFICATION
      value: "false"
    - name: MM_EMAILSETTINGS_FEEDBACKEMAIL
      value: "mattermost@ii.coop"
    - name: MM_EMAILSETTINGS_FEEDBACKORGANIZATION
      value: "ii.coop"
    - name: MM_EMAILSETTINGS_SENDEMAILNOTIFICATIONS
      value: "true"
    - name: MM_EMAILSETTINGS_SENDPUSHNOTIFICATIONS
      value: "true"
    - name: MM_EMAILSETTINGS_PUSHNOTIFICATIONSERVER
      value: "https://push-test.mattermost.com"
    - name: MM_EMAILSETTINGS_PUSHNOTIFICATIONCONTENTS
      value: "full"
    - name: MM_EMAILSETTINGS_ENABLESMTPAUTH
      value: "true"
    - name: MM_GITLABSETTINGS_ID
      valueFrom:
        secretKeyRef:
          name: mattermost-user-config
          key: MM_GITLABSETTINGS_ID
    - name: MM_GITLABSETTINGS_SECRET
      valueFrom:
        secretKeyRef:
          name: mattermost-user-config
          key: MM_GITLABSETTINGS_SECRET
    - name: MM_GITLABSETTINGS_AUTHENDPOINT
      valueFrom:
        secretKeyRef:
          name: mattermost-user-config
          key: MM_GITLABSETTINGS_AUTHENDPOINT
    - name: MM_GITLABSETTINGS_TOKENENDPOINT
      valueFrom:
        secretKeyRef:
          name: mattermost-user-config
          key: MM_GITLABSETTINGS_TOKENENDPOINT
    - name: MM_GITLABSETTINGS_USERAPIENDPOINT
      valueFrom:
        secretKeyRef:
          name: mattermost-user-config
          key: MM_GITLABSETTINGS_USERAPIENDPOINT
    - name: MM_EMAILSETTINGS_ENABLESIGNINWITHEMAIL
      valueFrom:
        secretKeyRef:
          name: mattermost-user-config
          key: MM_EMAILSETTINGS_ENABLESIGNINWITHEMAIL
    - name: MM_EMAILSETTINGS_ENABLESIGNINWITHUSERNAME
      valueFrom:
        secretKeyRef:
          name: mattermost-user-config
          key: MM_EMAILSETTINGS_ENABLESIGNINWITHUSERNAME
    - name: MM_EMAILSETTINGS_FEEDBACKNAME
      valueFrom:
        secretKeyRef:
          name: mattermost-user-config
          key: MM_EMAILSETTINGS_FEEDBACKNAME
    - name: MM_EMAILSETTINGS_SMTPUSERNAME
      valueFrom:
        secretKeyRef:
          name: mattermost-user-config
          key: MM_EMAILSETTINGS_SMTPUSERNAME
    - name: MM_EMAILSETTINGS_SMTPPASSWORD
      valueFrom:
        secretKeyRef:
          name: mattermost-user-config
          key: MM_EMAILSETTINGS_SMTPPASSWORD
    - name: MM_EMAILSETTINGS_SMTPSERVER
      valueFrom:
        secretKeyRef:
          name: mattermost-user-config
          key: MM_EMAILSETTINGS_SMTPSERVER
    - name: MM_EMAILSETTINGS_SMTPPORT
      valueFrom:
        secretKeyRef:
          name: mattermost-user-config
          key: MM_EMAILSETTINGS_SMTPPORT
    - name: MM_EMAILSETTINGS_CONNECTIONSECURITY
      valueFrom:
        secretKeyRef:
          name: mattermost-user-config
          key: MM_EMAILSETTINGS_CONNECTIONSECURITY
#+end_src

#+name: wait-for-mattermost-db-creds
#+begin_src tmate :dir . :window cluster
until kubectl -n mattermost get secret/mattermost.mattermost-db.credentials; do
  sleep 5s
done
#+end_src

#+name: create-mattermost-database-connection-string
#+begin_src tmate :dir . :window cluster
POSTGRES_PASSWORD="$(kubectl -n mattermost get secret mattermost.mattermost-db.credentials -o=jsonpath='{.data.password}' | base64 -d)"
kubectl -n mattermost create secret generic mattermost-database --from-literal=DB_CONNECTION_STRING="postgres://mattermost:$POSTGRES_PASSWORD@mattermost-db-pooler:5432/mattermost?sslmode=require" -o yaml --dry-run=client | \
    kubectl apply -f -
#+end_src

#+name: install-mattermost-cluster
#+begin_src tmate :dir . :window cluster
envsubst < ./mattermost.yaml | kubectl -n mattermost apply -f -
#+end_src

Backup CronJob for Mattermost, storing [Postgres, MinIO, Config] all to a s3 bucket each week at 8:45 on a Tuesday
#+begin_src yaml :tangle ./mattermost-backup.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: mattermost-backup
  namespace: mattermost
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: mattermost-backup
  namespace: mattermost
rules:
- apiGroups:
    - ""
  resources:
    - pods
  verbs:
    - get
    - list
- apiGroups:
    - apps
  resources:
    - deployments
  verbs:
    - get
    - list
- apiGroups:
    - ""
  resources:
    - pods/exec
  verbs:
    - create
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: mattermost-backup
  namespace: mattermost
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: mattermost-backup
subjects:
- kind: ServiceAccount
  name: mattermost-backup
  namespace: mattermost
---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: mattermost-backup
  namespace: mattermost
spec:
  jobTemplate:
    metadata:
      name: mattermost-backup
    spec:
      template:
        metadata:
          labels:
            app: mattermost-backup
        spec:
          serviceAccountName: mattermost-backup
          volumes:
            - name: tmp
              emptyDir: {}
          initContainers:
            - name: get-date
              image: alpine:3.15
              command:
                - sh
                - -x
                - -c
                - date +%Y%m%d%H%M | tee /tmp/date.txt
              volumeMounts:
                - name: tmp
                  mountPath: /tmp
            - name: dump-config
              image: alpine:3.15
              command:
                - sh
                - -x
                - -c
                - |
                  DATE="$(cat /tmp/date.txt)" && \
                  apk add --no-cache curl && \
                  curl -L -o /usr/local/bin/kubectl https://dl.k8s.io/v1.23.3/bin/linux/amd64/kubectl && \
                  chmod +x /usr/local/bin/kubectl && \
                  kubectl -n mattermost exec -it -c mattermost deployment/mattermost -- cat /mattermost/config/config.json > /tmp/mattermost-config-${DATE}.json && \
                  cd /tmp && \
                  tar cvf /tmp/mattermost-config-${DATE}.json.tar.gz /tmp/mattermost-config-${DATE}.json
              volumeMounts:
                - name: tmp
                  mountPath: /tmp
            - name: dump-database
              image: postgres:13.6-alpine
              envFrom:
                - secretRef:
                    name: mattermost-database
              command:
                - sh
                - -x
                - -c
                - |
                  DATE="$(cat /tmp/date.txt)" && \
                  pg_dump "${DB_CONNECTION_STRING}" -f /tmp/mattermost-db-${DATE}.sql && \
                  cd /tmp && \
                  tar cvf ./mattermost-db-${DATE}.sql.tar.gz /tmp/mattermost-db-${DATE}.sql
              volumeMounts:
                - name: tmp
                  mountPath: /tmp
            - name: dump-minio
              image: minio/mc:RELEASE.2022-02-13T23-26-13Z
              env:
                - name: MINIO_ACCESS_KEY
                  valueFrom:
                    secretKeyRef:
                      name: mattermost-minio
                      key: accesskey
                - name: MINIO_SECRET_KEY
                  valueFrom:
                    secretKeyRef:
                      name: mattermost-minio
                      key: secretkey
                - name: MINIO_HOST
                  value: mattermost-minio-hl-svc.mattermost:9000
                - name: MINIO_BUCKET
                  value: mattermost
              command:
                - sh
                - -x
                - -c
                - |
                  DATE="$(cat /tmp/date.txt)" && \
                  microdnf install tar && \
                  mc config host add mattermostminio http://mattermost-minio-hl-svc.mattermost:9000 ${MINIO_ACCESS_KEY} ${MINIO_SECRET_KEY} && \
                  mc cp --recursive mattermostminio/mattermost /tmp/mattermost-minio-${DATE}/ && \
                  cd /tmp/mattermost-minio-${DATE}/ && \
                  tar cvf ../mattermost-minio-${DATE}.tar.gz .
              volumeMounts:
                - name: tmp
                  mountPath: /tmp
          containers:
          - name: mattermost-backup
            image: amazon/aws-cli:2.4.18
            envFrom:
              - secretRef:
                  name: aws-serviceaccount-secret
            env:
              - name: S3_BUCKET
                value: ii-nz
            command:
              - sh
              - -x
              - -c
              - |
                DATE="$(cat /tmp/date.txt)" && \
                aws configure set aws_access_key_id "${AWS_ACCESS_KEY}" && \
                aws configure set aws_secret_access_key "${AWS_SECRET_KEY}" && \
                aws configure set default.region ap-southeast-2 && \
                cd /tmp && \
                for FILE in mattermost*.tar.gz; do
                  aws s3 cp "${FILE}" "s3://${S3_BUCKET}/mattermost-backup/${DATE}/${FILE}"
                done
              # - sleep 100000
            volumeMounts:
              - name: tmp
                mountPath: /tmp
          restartPolicy: OnFailure
  schedule: 45 8 * * 2
  # schedule: "*/30 * * * *"
#+end_src

TODO:
- add IAM account with Bucket access role
- test the CronJob

Apply the CronJob
#+begin_src tmate :window cluster
kubectl apply -f ./mattermost-backup.yaml
#+end_src

Watch the mattermost-backup pod
#+begin_src tmate :window cluster
kubectl -n mattermost get pods -l app=mattermost-backup -w
#+end_src

Get logs
#+begin_src tmate :window cluster
kubectl -n mattermost logs -l app=mattermost-backup --tail=10 -f
#+end_src

** Certs
#+begin_src yaml :tangle ./certs-mattermost.yaml
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: letsencrypt-prod-mattermost
  namespace: mattermost
spec:
  secretName: mattermost-ii-coop-tls-cert
  issuerRef:
    name: letsencrypt-prod
    kind: ClusterIssuer
    group: cert-manager.io
  commonName: mattermost.ii.coop
  dnsNames:
    - mattermost.ii.coop
#+end_src

#+begin_src tmate :dir . :window cluster
envsubst < ./certs-mattermost.yaml | kubectl apply -f -
#+end_src

** Migrating Mattermost
#+begin_src shell
# exec into the omnibus container
docker-compose exec gitlab.ii.coop bash
# become the gitlab-psql user
su gitlab-psql -c bash
# run the backup command
/opt/gitlab/embedded/bin/pg_dump -U gitlab-psql -h /var/opt/gitlab/postgresql mattermost_production -w | gzip > /tmp/mattermost_dbdump_$(date --rfc-3339=date).sql.gz
# return to the root user
exit
# include the mattermost data
tar -zcvf /tmp/mattermost_data_$(date --rfc-3339=date).gz -C /var/opt/gitlab/mattermost data config.json
exit
# copy the back up out
docker cp $(docker ps | grep gitlab.ii.coop | awk '{print $1}'):/tmp/mattermost_data_$(date --rfc-3339=date).gz /tmp/mattermost_data.gz
docker cp $(docker ps | grep gitlab.ii.coop | awk '{print $1}'):/tmp/mattermost_dbdump_$(date --rfc-3339=date).sql.gz /tmp/mattermost_dbdump.sql.gz
#+end_src

Copy the databse
#+begin_src tmate :window mmm
scp root@147.75.69.207:/tmp/mattermost_dbdump.sql.gz /tmp/mattermost_dbdump.sql.gz
#+end_src

Copy the data
#+begin_src tmate :window mmm
scp root@147.75.69.207:/tmp/mattermost_data.gz /tmp/mattermost_data.gz
#+end_src

Port-forward the remote database
#+begin_src tmate :window mmm
export KUBECONFIG=~/.kube/config-ii-coop
kubectl -n mattermost port-forward svc/mattermost-db-pooler 5432
#+end_src

Restore the database
#+begin_src tmate :window cluster
zcat /tmp/mattermost_dbdump.sql.gz | psql $(kubectl -n mattermost get secret mattermost-database -o=jsonpath='{.data.DB_CONNECTION_STRING}' | base64 -d | sed 's/mattermost-db-pooler/localhost/g')
#+end_src

Extract the data
#+begin_src tmate :window cluster
mkdir -p /tmp/mattermost-data
tar -xzvf /tmp/mattermost_data.gz -C /tmp/mattermost-data
#+end_src

Port-forward the MinIO server
#+begin_src tmate :window mmm
export KUBECONFIG=~/.kube/config-ii-coop
kubectl -n mattermost port-forward svc/mattermost-minio-hl-svc 9000
#+end_src

Configure the connection to the MinIO server
#+begin_src tmate :window cluster
mc alias set mattermost-minio-hl-svc http://localhost:9000 $(kubectl -n mattermost get secrets mattermost-minio -o=jsonpath='{.data.accesskey}' | base64 -d) $(kubectl -n mattermost get secrets mattermost-minio -o=jsonpath='{.data.secretkey}' | base64 -d)
#+end_src

Copy the data over to MinIO
#+begin_src tmate :window cluster
mc cp --recursive /tmp/mattermost-data/data/ mattermost-minio/mattermost/data/
#+end_src

** References
- https://docs.gitlab.com/omnibus/gitlab-mattermost/#back-up-gitlab-mattermost
- https://docs.mattermost.com/install/install-kubernetes.html

* Install Kanban
** Prepare
Create a namespace
#+begin_src tmate :window kanban
kubectl create ns kanban-ii-coop
#+end_src

#+RESULTS:
#+begin_example
namespace/kanban-ii-coop created
#+end_example

** Configure
Certs
#+begin_src yaml :tangle ./kanboard.yaml
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: kanban-ii-coop
spec:
  acme:
    email: kanban@ii.coop
    preferredChain: ""
    privateKeySecretRef:
      name: letsencrypt-prod
    server: https://acme-v02.api.letsencrypt.org/directory
    solvers:
    - http01:
        ingress:
          class: nginx
      selector:
        dnsNames:
        - kanban.ii.coop
---
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: kanban-ii-coop
  namespace: kanban-ii-coop
spec:
  dnsNames:
  - kanban.ii.coop
  issuerRef:
    group: cert-manager.io
    kind: ClusterIssuer
    name: kanban-ii-coop
  secretName: letsencrypt-prod
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: kanboard
  namespace: kanban-ii-coop
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: kanboard
  name: kanboard
  namespace: kanban-ii-coop
spec:
  replicas: 1
  selector:
    matchLabels:
      app: kanboard
  template:
    metadata:
      labels:
        app: kanboard
    spec:
      containers:
      - image: kanboard/kanboard:v1.2.20
        name: kanboard
        ports:
          - containerPort: 80
        volumeMounts:
          - name: kanboard
            mountPath: /var/www/app/data
      volumes:
      - name: kanboard
        persistentVolumeClaim:
          claimName: kanboard
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app: kanboard
  name: kanboard
  namespace: kanban-ii-coop
spec:
  ports:
  - port: 80
    protocol: TCP
    targetPort: 80
  selector:
    app: kanboard
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: kanboard
  namespace: kanban-ii-coop
  annotations:
    kubernetes.io/ingress.class: nginx
spec:
  rules:
  - host: kanban.ii.coop
    http:
      paths:
      - backend:
          service:
            name: kanboard
            port:
              number: 80
        path: /
        pathType: ImplementationSpecific
  tls:
  - hosts:
    - kanban.ii.coop
    secretName: letsencrypt-prod
#+end_src

** Install
Apply all the things
#+begin_src tmate :window kanban
kubectl apply -f kanboard.yaml
#+end_src

Waiting for cert
#+begin_src shell
kubectl -n kanban-ii-coop get challenges
#+end_src

#+RESULTS:
#+begin_example
#+end_example

Checkout the ingress
#+begin_src shell
kubectl -n kanban-ii-coop get ing
#+end_src

#+RESULTS:
#+begin_example
NAME       CLASS    HOSTS            ADDRESS          PORTS     AGE
kanboard   <none>   kanban.ii.coop   139.178.68.219   80, 443   10m
#+end_example

* Install Wireguard
** Prepare
#+begin_src tmate :window cluster
kubectl create namespace wireguard --dry-run=client -o yaml | \
    kubectl apply -f -
#+end_src
** Configure
#+begin_src yaml :tangle ./wireguard.yaml
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  namespace: wireguard
  name: wireguard-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 50Mi
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: wireguard-config
  namespace: wireguard
data:
  PUID: "1000"
  PGID: "1000"
  TZ: "Pacific/Auckland"
  SERVERPORT: "51820"
  SERVERURL: "wg.ii.coop"
  PEERS: "30"
  # PEERDNS: "10.43.0.30"
  PEERDNS: "auto"
  ALLOWEDIPS: "0.0.0.0/0, ::/0"
  INTERNAL_SUBNET: "10.13.13.0"
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wireguard
  namespace: wireguard
  labels:
    app: wireguard
spec:
  strategy:
    type: Recreate
  replicas: 1
  selector:
    matchLabels:
      app: wireguard
  template:
    metadata:
      labels:
        app: wireguard
    spec:
      containers:
      - name: wireguard
        image: docker.io/linuxserver/wireguard:v1.0.20210424-ls36
        envFrom:
        - configMapRef:
            name: wireguard-config
        securityContext:
          capabilities:
            add:
              - NET_ADMIN
              - SYS_MODULE
          privileged: true
        volumeMounts:
          - name: wg-config
            mountPath: /config
          - name: host-volumes
            mountPath: /lib/modules
        ports:
        - containerPort: 51820
          protocol: UDP
        resources:
          requests:
            memory: "64Mi"
            cpu: "10m"
          limits:
            memory: "128Mi"
            cpu: "100m"
      volumes:
        - name: wg-config
          persistentVolumeClaim:
            claimName: wireguard-pvc
        - name: host-volumes
          hostPath:
            path: /lib/modules
            type: Directory
---
apiVersion: v1
kind: Service
metadata:
  name: wireguard
  namespace: wireguard
spec:
  selector:
    app: wireguard
  ports:
    - name: wireguard
      port: 51820
      targetPort: 51820
      protocol: UDP
  externalTrafficPolicy: Local
  type: LoadBalancer
#+end_src

** Install
#+begin_src tmate :window cluster
kubectl apply -f ./wireguard.yaml
#+end_src

* Finalise
** Move ClusterAPI management
#+begin_src tmate :window SHELL
clusterctl move -n ii-coop --to-kubeconfig=$HOME/.kube/config-ii-coop
#+end_src


* Extras
** Move from Packet-CCM to Metal-CCM
Move config over and use LoadBalancer configuration pointing to MetalLB
#+begin_src tmate :window cluster
kubectl -n kube-system create secret generic metal-cloud-config --from-file=cloud-sa.json=<(kubectl -n kube-system get secret packet-cloud-config -o=jsonpath='{.data.cloud-sa\.json}' | base64 -d | jq -cr '. | .loadbalancer = "metallb:///"')
#+end_src

Remove the older Packet-CCM
#+begin_src tmate :window cluster
kubectl delete -f https://github.com/packethost/packet-ccm/releases/download/v2.0.0/deployment.yaml
#+end_src

Install Metal-CCM
#+begin_src tmate :window cluster
kubectl apply -f https://github.com/equinix/cloud-provider-equinix-metal/releases/download/v3.2.2/deployment.yaml
#+end_src

** cncf.ci redirect
#+NAME: Certs
#+begin_src yaml :tangle ./cncf-ci-redirect.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: cncf-ci-redirect
---
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: letsencrypt-prod
  namespace: cncf-ci-redirect
spec:
  secretName: letsencrypt-prod
  issuerRef:
    name: letsencrypt-prod
    kind: ClusterIssuer
  dnsNames:
    - cncf.ci
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: cncf-ci-redirect
  namespace: cncf-ci-redirect
  annotations:
    kubernetes.io/ingress.class: nginx
    nginx.ingress.kubernetes.io/configuration-snippet: |
      rewrite ^/(.*) https://github.com/cncf-ci permanent;
spec:
  rules:
  - host: cncf.ci
    http:
      paths:
      - backend:
          service:
            name: cncf-ci-redirect
            port:
              number: 8080
        path: /
        pathType: ImplementationSpecific
  tls:
  - hosts:
    - cncf.ci
    secretName: letsencrypt-prod
#+end_src

#+begin_src tmate :dir . :window cluster
envsubst < cncf-ci-redirect.yaml | kubectl apply -f -
#+end_src

** ii-nz-temp
*** multiplex
**** Configure
#+begin_src yaml :tangle ./ii-nz-temp/multiplex.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: ii-nz
---
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: multiplex-ii-nz-letsencrypt-prod
  namespace: ii-nz
spec:
  secretName: letsencrypt-prod
  issuerRef:
    name: letsencrypt-prod
    kind: ClusterIssuer
  dnsNames:
    - "multiplex.ii.nz"
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: reveal-multiplex
  name: reveal-multiplex
  namespace: ii-nz
spec:
  replicas: 1
  selector:
    matchLabels:
      app: reveal-multiplex
  template:
    metadata:
      labels:
        app: reveal-multiplex
    spec:
      containers:
      - name: reveal-multiplex
        image: registry.gitlab.com/ii/nz/reveal-multiplex
        imagePullPolicy: IfNotPresent
        livenessProbe:
          failureThreshold: 3
          periodSeconds: 10
          successThreshold: 1
          tcpSocket:
            port: http
          timeoutSeconds: 1
        ports:
        - containerPort: 1948
          name: http
          protocol: TCP
        readinessProbe:
          failureThreshold: 3
          periodSeconds: 10
          successThreshold: 1
          tcpSocket:
            port: http
          timeoutSeconds: 1
        securityContext:
          readOnlyRootFilesystem: true
          runAsGroup: 1000
          runAsNonRoot: true
          runAsUser: 1000
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app: reveal-multiplex
  name: reveal-multiplex
  namespace: ii-nz
spec:
  ports:
  - name: http
    port: 1948
    protocol: TCP
    targetPort: http
  selector:
    app: reveal-multiplex
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  labels:
    app: reveal-multiplex
  name: reveal-multiplex
  namespace: ii-nz
spec:
  rules:
  - host: multiplex.ii.nz
    http:
      paths:
      - backend:
          service:
            name: reveal-multiplex
            port:
              number: 1948
        path: /
        pathType: ImplementationSpecific
  tls:
  - hosts:
    - multiplex.ii.nz
    secretName: letsencrypt-prod
#+end_src

**** Install
#+begin_src tmate :dir . :window cluster
kubectl apply -f ./ii-nz-temp/multiplex.yaml
#+end_src

*** expo-prezzo
**** Configure
#+begin_src yaml :tangle ./ii-nz-temp/expo-prezzo.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: careers-expo-ii-nz
---
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: careers-expo-ii-nz-letsencrypt-prod
  namespace: careers-expo-ii-nz
spec:
  secretName: careers-expo-ii-nz-letsencrypt-prod
  issuerRef:
    name: letsencrypt-prod
    kind: ClusterIssuer
  dnsNames:
    - "careers-expo.ii.nz"
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: careers-expo-ii-nz
  namespace: careers-expo-ii-nz
  labels:
    environment: production
spec:
  replicas: 1
  selector:
    matchLabels:
      app: careers-expo-ii-nz
  template:
    metadata:
      labels:
        app: careers-expo-ii-nz
        environment: production
    spec:
      automountServiceAccountToken: false
      containers:
      - name: careers-expo-ii-nz
        image: registry.gitlab.com/ii/expo-prezzo:2021.08.12.1642
        imagePullPolicy: IfNotPresent
        securityContext:
          readOnlyRootFilesystem: true
          runAsUser: 1000
          runAsGroup: 1000
          allowPrivilegeEscalation: false
        imagePullPolicy: IfNotPresent
        ports:
          - containerPort: 8101
        env:
          - name: TZ
            value: "Pacific/Auckland"
        readinessProbe:
          tcpSocket:
            port: 8101
          initialDelaySeconds: 2
          periodSeconds: 10
        livenessProbe:
          tcpSocket:
            port: 8101
          initialDelaySeconds: 2
          periodSeconds: 10
          failureThreshold: 10
        resources:
          requests:
            memory: "400Mi"
            cpu: "1"
          limits:
            memory: "400Mi"
            cpu: "1"
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
            - matchExpressions:
              - key: kubernetes.io/arch
                operator: In
                values:
                - amd64
---
apiVersion: v1
kind: Service
metadata:
  name: careers-expo-ii-nz
  namespace: careers-expo-ii-nz
  labels:
    environment: production
spec:
  ports:
    - port: 8101
      targetPort: 8101
  selector:
    app: careers-expo-ii-nz
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: careers-expo-ii-nz
  namespace: careers-expo-ii-nz
  labels:
    environment: production
  annotations:
    cert-manager.io/cluster-issuer: careers-expo-ii-nz-letsencrypt-prod
    kubernetes.io/ingress.class: nginx
spec:
  tls:
    - hosts:
        - "careers-expo.ii.nz"
      secretName: careers-expo-ii-nz-letsencrypt-prod
  rules:
    - host: "careers-expo.ii.nz"
      http:
        paths:
          - path: /
            pathType: ImplementationSpecific
            backend:
              service:
                name: careers-expo-ii-nz
                port:
                  number: 8101
#+end_src

**** Install
#+begin_src tmate :dir . :window cluster
kubectl apply -f ./ii-nz-temp/expo-prezzo.yaml
#+end_src
